<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>springcloud微服务实战 学习笔记六 服务网关</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>####服务网关简介<br>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><p>###依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置</p><pre><code>spring.application.name=api-gatewayserver.port=5555#通过url的方式做服务转发（不推荐）#zuul.routes.api-a-url.path=/api-a-url/**#zuul.routes.api-a-url.url=http://localhost:2222/#通过serviceId的方式#api-a api-b只是自定义的名称zuul.routes.api-a.path=/api-a/**zuul.routes.api-a.serviceId=compute-service-azuul.routes.api-b.path=/api-b/**zuul.routes.api-b.serviceId=compute-service-b#注册为服务eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</code></pre><p>所有的<code>/api-a/**</code>路径的访问转发到compute-service-a服务<br>所有的<code>/api-b/**</code>路径的访问转发到compute-service-b服务<br>服务网关实现转发有两种方式，一种是通过url的方式转发，另一种是通过serviceId的方式转发。通过url转发的方式，则不需要eureka依赖。<br>推荐使用serviceId的映射方式，除了对Zuul维护上更加友好之外，serviceId映射方式还支持了断路器，对于服务故障的情况下，可以有效的防止故障蔓延到服务网关上而影响整个系统的对外服务</p><p>Application.java</p><pre><code>@EnableZuulProxy@SpringCloudApplicationpublic class Application {    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }    @Bean    public AccessFilter accessFilter(){        return new AccessFilter();    }}</code></pre><p>自定义过滤器AccessFilter.java</p><pre><code>public class AccessFilter extends ZuulFilter{    private static Logger log = LoggerFactory.getLogger(AccessFilter.class);    @Override    public String filterType() {        return &quot;pre&quot;;    }    @Override    public int filterOrder() {        return 0;    }    @Override    public boolean shouldFilter() {        return true;    }    @Override    public Object run() {        RequestContext currentContext = RequestContext.getCurrentContext();        HttpServletRequest request = currentContext.getRequest();        log.info(String.format(&quot;%s request to %s&quot;, request.getMethod(), request.getRequestURL().toString()));        String accessToken = request.getParameter(&quot;accessToken&quot;);        if(accessToken==null){            log.warn(&quot;access token is empty&quot;);            currentContext.setSendZuulResponse(false);            currentContext.setResponseStatusCode(401);            currentContext.setResponseBody(&quot;accessToken is null&quot;);            return null;        }        log.info(&quot;access token ok&quot;);        return null;    }}</code></pre><p>自定义过滤器的实现，需要继承ZuulFilter，需要重写实现下面四个方法：</p><ul><li><p>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：</p><ul><li>pre：可以在请求被路由之前调用</li><li>routing：在路由请求时候被调用</li><li>post：在routing和error过滤器之后被调用</li><li>error：处理请求时发生错误时被调用</li></ul></li><li>filterOrder：通过int值来定义过滤器的执行顺序</li><li>shouldFilter：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。在上例中，我们直接返回true，所以该过滤器总是生效。</li><li>run：过滤器的具体逻辑。需要注意，这里我们通过ctx.setSendZuulResponse(false)令zuul过滤该请求，不对其进行路由，然后通过ctx.setResponseStatusCode(401)设置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过ctx.setResponseBody(body)对返回body内容进行编辑等。</li></ul><p>将服务网关注册为服务，将权限系统做成另外一个服务，在网关里面调用这个服务，来实现权限控制。</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战  学习笔记三 服务消费者</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      <content type="html"><![CDATA[<p>###第一种方式LoadBalancerClient</p><ul><li><p>依赖</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Dalston.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li><li><p>配置文件</p><pre><code>spring.application.name=eureka-consumerserver.port=3333#服务注册中心eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</code></pre></li><li><p>application</p><pre><code>@EnableDiscoveryClient@SpringBootApplicationpublic class Application {    @Bean    public RestTemplate restTemplate() {        return new RestTemplate();    }    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }}</code></pre></li><li><p>controller</p><pre><code>@RestControllerpublic class DemoController {    Logger logger = LoggerFactory.getLogger(this.getClass());    @Autowired    LoadBalancerClient loadBalancerClient;    @Autowired    RestTemplate restTemplate;    @GetMapping(&quot;/hello&quot;)    public String hello(){        ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;eureka-client&quot;);        logger.info(&quot;host:&quot;+serviceInstance.getHost()+&quot;---port:&quot;+serviceInstance.getPort()+&quot;---uri&quot;+serviceInstance.getUri());        String url = &quot;http://&quot;+serviceInstance.getHost()+&quot;:&quot;+serviceInstance.getPort()+&quot;/hello&quot;;        String forObject = restTemplate.getForObject(url, String.class);        return forObject;    }}</code></pre></li></ul><p>###第二种方式Ribbon</p><ul><li><p>依赖<br>在一种方式下添加依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件修改端口号即可<br>修改Application.java,在RestTemplate上添加注解</p><pre><code>@Bean@LoadBalancedpublic RestTemplate restTemplate() {    return new RestTemplate();}</code></pre></li></ul><p>controller修改为</p><pre><code>@GetMapping(&quot;/hello2&quot;)public String hello2(){    return restTemplate.getForObject(&quot;http://eureka-client/hello&quot;,String.class);}</code></pre><p>###第三种方式Feign</p><ul><li><p>依赖<br>在第一种方式下添加依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件修改端口号即可</p></li></ul><p>Application.java添加注解<code>@EnableFeignClients</code>支持Feign客户端</p><pre><code>@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }}</code></pre><p>创建一个接口<br><code>@FeignClient(&quot;eureka-client&quot;)</code>设置使用的服务名称</p><pre><code>@FeignClient(&quot;eureka-client&quot;)public interface DemoService {    @GetMapping(&quot;/hello&quot;)    String hello();}</code></pre><p>controller</p><pre><code>@RestControllerpublic class DemoController {    Logger logger = LoggerFactory.getLogger(this.getClass());    @Autowired    DemoService demoService;    @GetMapping(&quot;/hello&quot;)    public String hello(){        return demoService.hello();    }}</code></pre><p>三种方式可以混合使用，第二种方式因为将RestTemplate对象添加了注解，所以第一种方式就不能直接使用了，只能利用其它方式发送http请求获取数据。</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>冒泡排序java实现</title>
      <link href="/2018/09/26/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/26/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>数据结构中的几个排序冒泡排序算是最简单的一个了,基本的思路就是从最开始的一个元素依次和后面的元素比较,如果后面的元素比较小,那就和第一个元素交换,就这样,从第一个比较到最后一个.<br>代码实现:</p><pre><code>public static void sort(int[] arr){    //依次遍历整个数组    for (int i = 0; i &lt; arr.length; i++) {        //将当前的元素与后面的元素依次比较,如果后面的元素比较大,则交换位置        for (int j = i; j &lt; arr.length; j++) {            if(arr[i]&gt;arr[j]){                int temp=arr[i];                arr[i]=arr[j];                arr[j] = temp;            }        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>面试复习笔记三(sql)</title>
      <link href="/2018/09/26/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89(sql)/"/>
      <url>/2018/09/26/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89(sql)/</url>
      <content type="html"><![CDATA[<p>脏读:<br>幻读:<br>不可重复读:<br>第一类丢失更新:<br>第二类丢失更新:</p><p>select语句执行顺序:from-&gt;where-&gt;select-&gt;orderby<br>聚集函数:对一组数据返回一个值.一般使用orderby分组.<br>having 分组之后的条件.<br>数据库的三范式：<br>1NF：一个列只能有一个数据<br>2NF:每行数据都要一个主键<br>3NF:不能有冗余数据</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记四 分布式配置中心</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>####介绍<br>Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。</p><p>####依赖</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Dalston.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>####配置文件</p><pre><code>spring.application.name=config-serverserver.port=1201# git仓库配置spring.cloud.config.server.git.uri=https://github.com/zhumeilu/springcloud-config-repo-demo/#spring.cloud.config.server.git.searchPaths=Chapter1-1-8/config-repospring.cloud.config.server.git.username=spring.cloud.config.server.git.password=</code></pre><p>####Application.java</p><pre><code>@EnableConfigServer  //开启配置中心服务@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }}</code></pre><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>{label}对应Git上不同的分支，默认为master,{application}为配置的文件名称，{profile}为环境<br>访问<a href="http://localhost:1201/config-client/dev/master就可以看到配置文件了" target="_blank" rel="noopener">http://localhost:1201/config-client/dev/master就可以看到配置文件了</a></p><p>###客户端</p><p>构建一个简单的springboot应用<br>配置文件</p><pre><code>spring.application.name=eureka-consumerserver.port=4444eureka.instance.hostname=localhost#服务注册中心#eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/spring.cloud.config.profile=devspring.cloud.config.name=config-clientspring.cloud.config.uri=http://localhost:1201/spring.cloud.config.label=master</code></pre><p>在controller中添加</p><pre><code>@Value(&quot;${from}&quot;)String from;@GetMapping(&quot;/getFrom&quot;)public String getFrom(){    return from;}</code></pre><p>访问<a href="http://localhost:4444/getForm" target="_blank" rel="noopener">http://localhost:4444/getForm</a><br>得到配置文件中的form的值</p><p>在客户端使用配置中心时，spring.cloud.config.name和spring.application.name都可以确定配置文件名称，最好使用spring.cloud.config.name=config-client来确定配置文件名称，不要使用spring.application.name=config-client来确定。如果都存在的话，默认使用spring.cloud.config.name</p><p>###配置中心集群<br>将多个配置中心注册为服务，使其实现集群和负载均衡</p><p>####服务端</p><p>依赖<br>在之前的基础上添加依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件<br>在之前的基础上添加注册中心</p><pre><code># 配置服务注册中心eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</code></pre><p>Application.java</p><p>添加注解<code>@EnableDiscoveryClient  //注解使其成为服务</code></p><p>####客户端</p><p>配置文件<br>在原来的基础是添加</p><pre><code>#开启通过服务来访问Config Server的功能spring.cloud.config.discovery.enabled=true#指定Config Server注册的服务名spring.cloud.config.discovery.serviceId=config-server</code></pre><p>当git上的配置文件更新时，可以在项目中添加spring-boot-starter-actuator模块，在需要刷新的controller上添加注解<code>@RefreshScope</code>然后访问/refresh，需要注意的是springboot中默认开启安全策略，无法通过fidder或者postman之类的工具调用/refresh，所以需要设置management.security.enabled= false</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>希尔排序java实现</title>
      <link href="/2018/09/26/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/26/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>希尔排序个人感觉还是有一点难度的,当时在理解的时候花了不少时间.<br>希尔排序这里面有一个叫做”步长”的概念.就是每次通过这些步长找出一组元素,然后对这些元素进行排序.<br>步长的初始值一般都是数组长度的1/2,然后不断地取其1/2.</p><p>代码:</p><pre><code>private static void sort(int[] arr,int step){    for (int i = step; i &lt; arr.length; i++) {        for (int j = i; j &gt;=step; j-=step) {            if(arr[j]&lt;arr[j-step]){                int temp = arr[j];                arr[j] = arr[j-step];                arr[j-step]=temp;            }else{                break;            }        }    }}public static void main(String[] args) {    int[] arr = new int[]{1,4,2,6,9,6};    for (int i = arr.length/2; i &gt; 0; i/=2) {        sort(arr,i);    }}</code></pre><p>书上的代码:</p><pre><code>void shellsort(int[] arr){    int j;    for (int gap = arr.length/2; gap &gt;0; gap/=2) {        for (int i = gap; i &lt; arr.length; i++) {            int temp=arr[i];            for(j=i;j&gt;=gap&amp;&amp;temp&lt;arr[j-gap];j-=gap){                arr[j] = arr[j-gap];            }            arr[j]=temp;        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java支付宝支付(即时到账)</title>
      <link href="/2018/09/26/java%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98-%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6/"/>
      <url>/2018/09/26/java%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98-%E5%8D%B3%E6%97%B6%E5%88%B0%E8%B4%A6/</url>
      <content type="html"><![CDATA[<p>第一次接触支付宝支付的开发,大概花了半天的 时间才了解到原来我需要开发的是即时到账功能.因为支付宝里面也有和微信一样的获取一个支付的二维码,叫做当面支付,之前一直以为自己要做这个,然而公司根本就没申请这个.</p><p> 简单介绍一下,支付宝支付一共分为:即时到账,手机网站支付,app支付,当面付这四种支付方式,即时到账的流程就是先签约,然后根据文档里面介绍的获取pid,配置密钥,密钥需要自己下载支付宝提供的一个工具在本地生成RSA公钥和私钥,然后上传公钥,接着获取支付宝的RSA公钥.</p><p>接下来就是下载文档里面提供的demo了.这个demo基本上可以满足一般的功能开发了.</p><p>在这个demo里面,首先在AlipayConfig.java里面将一些参数配置好,partner就是pid,然后在将你在本地生成的私钥和在支付账户里面的支付宝公钥配置好,接着就是支付成功之后的异步通知url和支付成功之后的页面跳转url(这个和微信不一样,微信没有,如果用户支付成功之后没有关闭页面,那么就会跳转到这个url,就可以直接获得支付结果然后改变订单状态了).</p><p>demo里面的alipayapi.jsp的代码就是发送支付请求的代码,拷贝过去然后修改一些订单号和商品名已经金额什么的基本上就ok了,这里面有一点需要注意,就是需要在response里面设置编码为utf-8,不然在支付宝支付的页面里面商品名就会有中文乱码,然后return_url.jsp里面的代码和notify_url.jsp都差不多,修改修改就可以直接使用了.</p><p>感觉支付宝支付还是蛮简单的,相对于微信,貌似微信没有java的demo,什么请求都需要自己手动写.</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从零开始netty学习笔记之BIO</title>
      <link href="/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBIO/"/>
      <url>/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBIO/</url>
      <content type="html"><![CDATA[<p>BIO即Block IO，阻塞式IO。<br>网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字（Socket）进行通信。<br>在基于传统同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口：Socket负责发起连接操作。连接成功之后，双方通过输入和输出流进行同步阻塞式通信。</p><p>####传统阻塞式IO<br>BIO服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完之后，通过输出流返回应答给客户端，线程销毁。<br>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量则增加后，服务端的线程个数和客户端并发访问数呈1：1的正比关系，由于线程是java虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能 将急剧下降，随着并发访问量的继续增大，系统会发生线程堆栈溢出、创建新线程失败等问题，并最终导致进程宕机或者僵死，不能对外提供服务。<br>传统的BIO<br>代码演示：<br>服务端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class TimeServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int port = 8081;</span><br><span class="line">        if(args!=null&amp;&amp;args.length&gt;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                port = Integer.valueOf(args[0]);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ServerSocket serverSocket = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            serverSocket = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;服务器已经启动--端口号：&quot;+port);</span><br><span class="line">            Socket socket = null;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                new Thread(new TimeServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(serverSocket!=null)&#123;</span><br><span class="line">                System.out.println(&quot;服务器关闭&quot;);</span><br><span class="line">                try&#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;catch (Exception e1)&#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                serverSocket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class TimeServerHandler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public TimeServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(this.socket.getOutputStream(),true);</span><br><span class="line">            String currentTime = null;</span><br><span class="line">            String body = null;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                body = in.readLine();</span><br><span class="line">                if(body == null)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;服务器收到消息：&quot;+body);</span><br><span class="line">                currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body)? new Date(System.currentTimeMillis()).toString():&quot;BAD ORDER&quot;;</span><br><span class="line">                out.println(currentTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            if(in!=null)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;catch (Exception e1)&#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out!=null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(this.socket!=null)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    this.socket.close();</span><br><span class="line">                &#125;catch (Exception e1)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                this.socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class TimeClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        int port = 8081;</span><br><span class="line">        if(args!=null&amp;&amp;args.length&gt;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                port = Integer.valueOf(args[0]);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out  = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            socket = new Socket(&quot;127.0.0.1&quot;,port);</span><br><span class="line">            in  = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            out.println(&quot;QUERY TIME ORDER&quot;);</span><br><span class="line">            System.out.println(&quot;发送命令成功&quot;);</span><br><span class="line">            String resp = in.readLine();</span><br><span class="line">            System.out.println(&quot;收到的消息：&quot;+resp);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(out!=null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(in!= null)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;catch (Exception e2)&#123;</span><br><span class="line">                    e2.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket!= null)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;catch (Exception e2)&#123;</span><br><span class="line">                    e2.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1483237-19955bb4609fc4bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="57D68050-8C99-40EE-8760-18878851D2D7.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1483237-21505543edb6d820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="55CC2938-2F41-4307-A8FF-265BF1165DE7.png"></p><p>传统的BIO每当一个新的客户端请求接入时，服务端必须创建一个新的线程处理接入的客户端链路，一个线程只能处理一个客户端连接。在高性能服务器应用领域，往往需要面向成千上万个客户端的并发连接，所以这种模型肯定无法满足高性能高并发的 场景。</p><p>####伪异步IO编程</p><p>伪异步的原理就是后端通过一个线程池来处理过个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N。通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><p>具体实现：当有新的客户端接入时，将客户端的Socket封装成一个Task（该任务实现Runnable接口）投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。<br>代码演示：<br>线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TimeServerHandlerExecutePool &#123;</span><br><span class="line"></span><br><span class="line">    private ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    public TimeServerHandlerExecutePool(int maxPoolSize,int queueSize)&#123;</span><br><span class="line"></span><br><span class="line">        this.executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),</span><br><span class="line">                maxPoolSize,120L, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;Runnable&gt;(queueSize));</span><br><span class="line">    &#125;</span><br><span class="line">    public void execute(Runnable task)&#123;</span><br><span class="line">        executorService.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>server代码和原来差不多，只是将原来的创建线程改为使用线程池来执行这个任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">serverSocket = new ServerSocket(port);</span><br><span class="line">           System.out.println(&quot;服务器已经启动--端口号：&quot;+port);</span><br><span class="line">           Socket socket = null;</span><br><span class="line">           TimeServerHandlerExecutePool  singleExecutor = new TimeServerHandlerExecutePool(50,10000);//创建IO任务线程池</span><br><span class="line">           while (true)&#123;</span><br><span class="line">               socket = serverSocket.accept();</span><br><span class="line">               singleExecutor.execute(new TimeServerHandler(socket));</span><br><span class="line"></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p><p>伪异步IO弊端分析：<br>read<br>当对Socket的输入流进行读取操作的时候，它会一直阻塞下去，知道发生如下三种事件。</p><ul><li>有数据可读</li><li>可用数据已经读取完毕</li><li>发生空指针异常或者IO异常<br>这意味着当对方发送请求或者应答消息比较缓慢，或者网络传输较慢时，读取输入流一方的通信线程将被长时间阻塞，如果对方要60s才能够将数据发送完毕，读取一方的IO线程也将被同步阻塞60s，在此期间，其他接入消息只能在消息队列中排队。<br>write<br>当调用OutputStream的write方法写输出流的时候，它将会被阻塞，知道所有要发送的字节全部写入完毕，或者发生异常。学习过TCP/IP相关知识的人都知道，当消息的接收方处理缓慢的时候，将不能及时的从TCP缓冲区读取数据，这将会导致发送方的TCP window size不断减少，知道为0，双方处于Keep-Alive状态，消息发送方将不能再向TCP缓冲区写入消息，这时如果采用的是同步阻塞IO，write操作将会被无线阻塞，知道TCP window size大于0或者发生IO异常。</li></ul><p>通过对输入和输出流的API进行分析，读和写操作都是同步阻塞的，阻塞的时间取决于对方对方IO线程的处理速度和网络IO的传输速度。本质上来讲，我们无法保证生产环境的网络状况和对端的应用程序能足够快，如果我们的应用程序依赖对方的处理速度，它的可靠性就非常差。</p>]]></content>
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从零开始netty学习笔记之netty简单demo</title>
      <link href="/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bnetty%E7%AE%80%E5%8D%95demo/"/>
      <url>/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bnetty%E7%AE%80%E5%8D%95demo/</url>
      <content type="html"><![CDATA[<p>服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class TimeServer &#123;</span><br><span class="line"></span><br><span class="line">    public void bind(int port) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        //配置服务端的NIO线程组</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">            b.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,1024)</span><br><span class="line">                    .childHandler(new ChildChannelHandler());</span><br><span class="line">            //绑定端口，同步等待成功</span><br><span class="line">            ChannelFuture f= b.bind(port).sync();</span><br><span class="line">            //等待服务器监听端口关闭</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            //优雅退出，释放线程池资源</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt;&#123;</span><br><span class="line"></span><br><span class="line">        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">            socketChannel.pipeline().addLast(new TimeServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        if(args!=null&amp;&amp;args.length&gt;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                port = Integer.valueOf(args[0]);</span><br><span class="line">            &#125;catch (NumberFormatException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        new TimeServer().bind(port);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先创建了两个NioEventLoopGroup实例。NioEventLoopGroup是个线程组，它包含了一组NIO线程，专门用于网络时间的处理，实际上它们就是Reactor线程组。这里创建两个的原因是一个用于服务端接受客户端的链接，另一个用于进行SocketChannel的网络读写。<br>然后创建了ServerBootstrap对象，它是Netty用于启动NIO服务端的辅助启动类，目的是降低服务端开发的复杂度。接着调用ServerBootstrap的group方法，将两个NIO线程组当做参数传递到ServerBootstrap中。<br>接着设置创建的Channel为NioServerChannel，它的功能对于与JDK NIO类库中的ServerSocketChannel类。然后配置NIOServerSocketChannel的TCP参数，此处将它的backlog设置为1024，最后绑定IO事件的处理类ChildChannelHandler，它的作用类似于Reactor模式中的Handler类，主要用于处理网络IO事件，例如记录日志，对消息进行编码解码等。<br>服务端启动辅助类配置完成之后，调用它的bind方法绑定监听端口，随后，调用它的同步阻塞方法sync等待绑定操作完成。完成时候Netty返回一个ChannelFuture，它的功能类似于JDK的java.util.concurrent.Future，主要用于异步操作的通知回调。<br>使用f.channel().closeFuture.sync()方法进行阻塞，等待服务器链路关闭之后main函数才退出。<br>调用NIO线程组的shutdownGracefully进行优雅退出，它会释放跟shutdownGracefuly相关联的资源。<br>服务端处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TimeServerHandler extends ChannelHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">        byte[] req = new byte[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = new String(req,&quot;utf-8&quot;);</span><br><span class="line">        System.out.println(&quot;服务器收到命令：&quot;+body);</span><br><span class="line">        String currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new Date(System.currentTimeMillis()).toString():&quot;BAD ORDER&quot;;</span><br><span class="line">        ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">        ctx.write(resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TimeServerHandler继承自 ChannelHandlerAdapter，它用于对网络事件进行读写操作，通常我们只需关注channelRead和exceptionCaught方法。<br>将msg转换 成Netty的ByteBuf对象。ByteBuf类似于JDK中的java.nio.ByteBuffer对象，不过它提供了更加强大和灵活的功能。通过ByteBuf的readableBytes方法可以获取缓冲区可读的字节数，根据可读的字节数创建byte数组，通过ByteBuf的readBytes方法将缓冲区中的字节数组复制到新建的byte数组中，最后通过new String构造函数获取请求消息。这是对请求消息进行判断，如果是”QUERY TIME ORDER”则创建应答消息，通过ChannelHandlerContext的write方法异步发送应答消息个客户端。<br>调用ChannelHandlerContext的flush方法，它的作用是将消息发送队列中的消息写入到SockChannel中发送给对方。从性能角度考虑，为了防止频繁地唤醒Selector进行消息发送，Netty的write方法并不直接将消息写入SocketChannel中，调用write方法只是把待发送的消息放到发送缓冲数组中，再通过调用flush方法，将发送缓冲区中的消息全部写入到SocketChannel中。</p><p>客户端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class TimeClient &#123;</span><br><span class="line"></span><br><span class="line">    public void connect(int port,String host)throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        //配置客户端NIO线程组</span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap b = new Bootstrap();</span><br><span class="line">            b.group(group).channel(NioServerSocketChannel.class).option(ChannelOption.TCP_NODELAY,true)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">                            socketChannel.pipeline().addLast(new TimeClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            //发起异步连接操作</span><br><span class="line">            ChannelFuture f= b.connect(host,port).sync();</span><br><span class="line">            //等待异步连接操作</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        if(args!=null&amp;&amp;args.length&gt;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                port = Integer.valueOf(args[0]);</span><br><span class="line">            &#125;catch (NumberFormatException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        new TimeClient().connect(port,&quot;127.0.0.1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建客户端处理IO读写的NioEventLoopGroup线程组，然后继续创建客户端辅助启动类Bootstrap，随后需要对其进行配置。与服务端不同的是，它的Channel需要设置为NioSocketChannel，然后为其添加Handler。此处为了简单直接创建匿名内部类，实现initChannel方法，其作用是当创建NioSocketChannel成功之后，在进行初始化时，将它的ChannelHandler设置到ChannelPipeline中，用于处理网络IO事件。<br>客户端启动辅助类设置完成之后，调用connect方法发起异步连接，然后调用同步方法等待连接成功。<br>最后当客户端连接关闭之后，客户端主函数退出，退出之前的释放NIO线程组的字眼。</p><p>客户端处理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TimeClientHandler extends ChannelHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private final ByteBuf firstMessage;</span><br><span class="line"></span><br><span class="line">    public TimeClientHandler() &#123;</span><br><span class="line">        byte[] req = &quot;QUERY TIME ORDER&quot;.getBytes();</span><br><span class="line">        firstMessage = Unpooled.buffer(req.length);</span><br><span class="line">        firstMessage.writeBytes(req);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;异常：&quot;+cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(firstMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">        byte[] req = new byte[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = new String (req,&quot;utf-8&quot;);</span><br><span class="line">        System.out.println(&quot;消息：&quot;+body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端和服务端TCP链路建立成功之后，Netty的NIO线程会调用channelActive方法，发送查询时间的指定给服务端，调用ChannelHandlerContext的writeAndFlush方法将请求消息发送给服务端。<br>当服务端返回应答消息时，channelRead被调用，从Netty的ByteBuf中读取并打印应答消息<br>当发生异常时，打印异常日志，释放客户端资源。</p>]]></content>
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记二 服务提供者</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85/</url>
      <content type="html"><![CDATA[<ul><li><p>添加依赖</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Dalston.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li><li><p>配置文件</p><pre><code>spring.application.name=eureka-clientserver.port=2222eureka.instance.hostname=localhost#服务注册中心eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</code></pre></li><li><p>Application.java</p><pre><code>@EnableDiscoveryClient@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }}</code></pre></li></ul><p>@EnableDiscoveryClient开启了服务发现</p><ul><li><p>controller</p><pre><code>@RestControllerpublic class DemoController {    Logger logger = LoggerFactory.getLogger(this.getClass());    @Autowired    DiscoveryClient  discoveryClient;    @GetMapping(&quot;/hello&quot;)    public String hello(){        logger.info(&quot;service:&quot;+ discoveryClient.getServices());        return &quot;hello world&quot;;    }}</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>选择排序java实现</title>
      <link href="/2018/09/26/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/26/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>选择排序,和冒泡排序一样,都是从第一个元素开始依次和后面的元素比较大小,不同的是选择排序每次比较之后,不交换位置,而是记录最小的元素的索引,这样在一次遍历完之后在将索引位置的元素与比较的元素交换,这样可以不用频繁的交换元素位置.<br>代码:</p><pre><code>public static void sort(int[] arr){    for (int i = 0; i &lt; arr.length; i++) {        int index=i;        for (int j = i; j &lt; arr.length; j++) {            if(arr[i]&gt;arr[j]){                index=j;            }        }        //判断索引值是否改变,如果改变,则交换元素        if(index!=i){            int temp=arr[i];            arr[i]=arr[index];            arr[index] = temp;        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第1条：考虑用静态工厂方法代替构造器</title>
      <link href="/2018/09/26/%E7%AC%AC1%E6%9D%A1%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/"/>
      <url>/2018/09/26/%E7%AC%AC1%E6%9D%A1%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>####优点</p><ul><li>静态工厂方法与构造器不同的第一大优势在于，它们有名称<br>根据名称，可以让人知道生成不同的对象</li><li>静态工厂方法与构造器不同的第二大优势在于，不必每次调用它们的时候都创建一个新对象<br>单例时或者内部有缓存时，可以进行复用。</li><li><p>静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface Service&#123;</span><br><span class="line">&#125;</span><br><span class="line">public interface Provider&#123;</span><br><span class="line">  Service newService();</span><br><span class="line">&#125;</span><br><span class="line">public class Services&#123;</span><br><span class="line">  private Service()&#123;&#125;</span><br><span class="line">  private static final Map&lt;String,Provider&gt; providers = new ConcurrentHashMap&lt;String,Provider&gt;();</span><br><span class="line">  public static final String DEFAUTL_PROVIDER_NAME = &quot;&lt;def&gt;&quot;;</span><br><span class="line">  public static void registerDefaultProvider(Provider p)&#123;</span><br><span class="line">    registerProvider(DEFAULT_PROVIDER_NAME,p);</span><br><span class="line">  &#125;</span><br><span class="line">  public static void registerProvider(String name,Provider p)&#123;</span><br><span class="line">    providers.put(name,p);</span><br><span class="line">  &#125;</span><br><span class="line">  public static Service newInstance(&#123;</span><br><span class="line">    return newInstance(DEFAULT_PROVIDER_NAME);</span><br><span class="line">  &#125;</span><br><span class="line">  public static Service newInstance(String name)&#123;</span><br><span class="line">    Provider p = providers.get(name);</span><br><span class="line">    if(p==null)</span><br><span class="line">      throw new IllegalArgumentException();</span><br><span class="line">    return p.newService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们会使代码变得更加简洁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,List&lt;String&gt;&gt; m = new HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">//代替</span><br><span class="line">public static &lt;K,V&gt; HashMap&lt;K,V&gt; newInstance()&#123;</span><br><span class="line">  return new HashMap&lt;K,V&gt;();</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt; m = HashMap.newInstance();</span><br></pre></td></tr></table></figure></li></ul><p>####缺点</p><ul><li>类如果不含公有的或者受保护的构造器，就不能被子类化。<br>没法被继承</li><li>它们与其他的静态方法实际上没有任何区别。<br>容易和其他静态方法搞混，最好通过命名将其区分开来，例如getInstance(),newInstance()</li></ul>]]></content>
      
      <categories>
          
          <category> effective java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从零开始netty学习笔记之TCP粘包和拆包</title>
      <link href="/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BTCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/"/>
      <url>/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BTCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>###TCP粘包/拆包</p><p>###发生的原因</p><p>###粘包问题的解决策略</p><p>###发生粘包演示</p>]]></content>
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第8条：覆盖equals请遵守通用约定</title>
      <link href="/2018/09/26/%E7%AC%AC8%E6%9D%A1%EF%BC%9A%E8%A6%86%E7%9B%96equals%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
      <url>/2018/09/26/%E7%AC%AC8%E6%9D%A1%EF%BC%9A%E8%A6%86%E7%9B%96equals%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
      <content type="html"><![CDATA[<p>覆盖equals时遵守几个原则。</p><ul><li>自反性<br>x.equals(x)返回true</li><li>对称性<br>x.equals(y) y.equals(x) 的结果相同</li><li>传递性<br>x.equals(y) y.equals(z) x.equals(z)</li><li>一致性<br>如果x,y没有被修改，那么多次调用x.equals(y) 的结果一定相同</li></ul>]]></content>
      
      <categories>
          
          <category> effective java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>idea下tomcat乱码</title>
      <link href="/2018/09/26/idea%E4%B8%8Btomcat%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/09/26/idea%E4%B8%8Btomcat%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>在配置tomcat的时候 VM options 中加入 -Dfile.encoding=UTF-8<br>进入idea的安装目录, 进入bin目录下。找到idea.exe.vmoptions这个文件 和 idea64.exe.vmoptions，在最后一行加入-Dfile.encoding=UTF-8，两个文件最好都要加</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>面试复习笔记一(java基础)</title>
      <link href="/2018/09/26/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-java%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/09/26/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-java%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>###==和equals之间的区别<br>==在基础数据类型中比较的是其数值,比如</p><pre><code>int i=1;int j=2;i==j;</code></pre><p>而==在对象之间比较的就是其对象的内存地址,也就是比较是否是同一个对象.<br>equals是Object类里面的方法,在Object类里面的默认实现其实就是使用==,然而有一些比较特殊的类,如String在继承Object类的时候将equals方法重写,<br>如:</p><pre><code>public boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String) anObject;        int n = value.length;        if (n == anotherString.value.length) {            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) {                if (v1[i] != v2[i])                        return false;                i++;            }            return true;        }    }    return false;}</code></pre><p>先用==比较,如果不是同一个对象,然后在比较值.</p><p>###switch可以作用在哪些类型上<br>switch可以作用在int上,由于byte,short,char可以隐式转换成int,所以也可以被switch使用,java7中,String也可以被switch使用</p><p>###&amp;和&amp;&amp;的区别<br>&amp;&amp;在比较的时候,如果第一个为false,则不会比较后面的,而&amp;则会比较全部的表达式.&amp;可以做位运算.</p><p>###final关键字<br>final关键字修饰的对象,对象引用不可改变,对象内容可以改变,也就是一旦该变量指向了该对象,那么就不能再给他赋值其他的对象了,但是对象里面的属性值可以修改.</p><p>###String和StringBuffer的区别<br>StringBuffer比String更能节省系统的资源,String内部是一个final修饰的char[],StringBuffer内部是一个char[],每次添加字符串的时候都是把字符串放入char[]中,中途会产生char[]数组的扩容和数组的复制.在进行字符串拼接的时候不会产生新的String,<br>而使用String+String拼接,会产生一个新的String对象.<br>系统有一个常量池,每次通过String a = “123”;这种方式产生的字符串时,系统都会从常量池中取,如果没有在创建一个放入常量池中,如果有,则直接拿来用.<br>而如果String a = new String(“123”);这种方式创建出来的String对象,则不会去常量池中取,而是作为一个普通的对象放入堆中.</p><p>###什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好<br>String a = “hello”+”world”;<br>StringBulider b  = new StringBulider(“hello”).append(“world”);<br>因为第一行语句,在编译的时候就自动整合成”helloworld”了.这是编译器的优化.</p><p>###StringBuffer和StringBulider的区别<br>StringBuffer和StringBulider功能类似,都是优化String的拼接.但是StringBulider是线程不安全的,而StringBuffer是线程安全的.StringBuffer的方法都加了synchronized修饰.<br>所以这就导致了StringBuffer的效率没有StringBulider高.<br>如果一个字符串是在方法内被定义,则推荐使用StringBulider.而如果是类的成员变量,并且会被多个线程同时访问,则使用StringBuffer.</p><p>###HashMap和HashTable的区别<br>HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。<br>     HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。<br>     HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。<br>     Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。<br>     最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。<br>     Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。<br>     就HashMap与HashTable主要从三方面来说。<br>一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现<br>二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的<br>三.值：只有HashMap可以让你将空值作为一个表的条目的key或value</p><p>###sleep和wait的区别<br>sleep是让出当前cpu,让cpu去执行其他的线程.不会释放锁.<br>wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法,调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行</p><p>###多线程有几种实现方法?同步有几种实现方法?<br>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>     同步的实现方面有两种，分别是synchronized,wait与notify<br>     wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>     sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>     notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>     Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p><p>##集合类的问题</p><p>###List和Set的区别<br>Set下面的实现由TreeSet和HashSet,每次插入操作的时候,Set都会根据自己特殊的比较器比较进行排序,与插入顺序无关,而且所有的元素不能重复,<br>Set的底层其实使用的是Map,只是使用了key,而忽略了value.<br>List的实现有ArrayList和LinkedList,List可以重复.<br>List的顺序和插入顺序有关</p><p>###foreach原理<br>foreach的原理就是调用对象的iterator()获取迭代器,然后遍历该对象,所以只要改集合实现了Iterator接口,就可以使用foreach,除此以外,还数组也可以使用foreach,其原理就是通过下标遍历对象.<br>在使用foreach遍历对象的时候,是不能修改集合结构的,但是集合元素的对象里面的属性是可以修改的.</p><p>###float和double的区别<br>定义float变量后面必须加f,double可以不加</p><p>###精度转换<br>高精度转低精度时,因为会丢失精确度,所以需要强制转换,<br>低精度转高精度时,不需要强制转换.</p><p>###Integer的比较<br>在-128到127之间,Integer会缓存,所以这个范围内的对象,如果值相等,那么其对象就相等.</p><pre><code>Integer f1 = 100,f2 = 100,f3 = 200,f4 = 200;System.out.print(f1 ==f2);System.out.print(f3 ==f4);</code></pre><p>###栈,堆,静态区<br>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。<br>    String a = new String(“hello”);<br>上面的语句中变量a放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。</p><p>###Math.round()<br>四舍五入的原理是在参数上加0.5然后进行下取整。</p><p>###最有效率的计算方法<br>使用位运算和加减来代替乘除</p><p>###数组中只有length数学,而String中有length()方法,集合中只有size()方法</p><p>###两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？<br>答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p><pre><code>补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</code></pre><p>###值传递和引用传递<br>java里面只有值传递,即使传递的是一个对象的引用,那也是传递对象的地址.</p><pre><code>public class User {    public int age = 18;    public static void main(String[] args) {        User user = new User();        change(user);        System.out.println(user.age);    }    public static void change(User user){        user.age = 100;        user = new User();    }}</code></pre><p>在这里,并没有改变传入的user对象,只是改变了user对象的属性.</p><p>###描述一下JVM加载class文件的原理机制？<br>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p><pre><code>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</code></pre><p>###Java中非静态内部类对象的创建要依赖其外部类对象</p><p>###java的内存泄漏<br>定义:对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。</p><p>###使用多线程的三种方式<br>继承Thread类,实现Runnable接口,实现Callable接口</p><pre><code>public class MyTask implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;lalala&quot;);        return 1;    }    public static void main(String[] args) throws InterruptedException, ExecutionException {        Callable&lt;Integer&gt; myTask = new MyTask();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myTask);        Thread thread = new Thread(futureTask);        thread.start();        System.out.println(futureTask.get());    }}</code></pre><p>###实现线程同步<br>使用synchronized,在方法上,或者代码块上.使用Look</p><pre><code>private Lock accountLock = new ReentrantLock();public void deposit(double money) {    accountLock.lock();    try {        double newBalance = balance + money;        try {            Thread.sleep(10); // 模拟此业务需要一段处理时间        }        catch (InterruptedException ex) {            ex.printStackTrace();        }        balance = newBalance;    }    finally {        accountLock.unlock();    }}</code></pre><p>###简述一下面向对象的”六原则一法则”</p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字”欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫”因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</li><li>依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）<br>里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）</li><li>合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）</li></ul>]]></content>
      
      <categories>
          
          <category> 面试复习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>spring boot redis做mybatis二级缓存</title>
      <link href="/2018/09/26/spring-boot-redis%E5%81%9Amybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>/2018/09/26/spring-boot-redis%E5%81%9Amybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<ul><li><p>添加依赖</p><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;  &lt;/dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre></li></ul><ul><li>application.properties</li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>Aplication</p><pre><code>@SpringBootApplication@EnableCachingpublic class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class,args);    }}</code></pre></li><li><p>mapper</p></li></ul><pre><code>@Component  //为了消除Controller里面的红线警告@Mapper@CacheConfig(cacheNames = &quot;users&quot;)public interface UserMapper {    @Cacheable    User get(Long id);    void insert(User user);    void update(User user);    List&lt;User&gt; list(UserQueryObject qo);    void delete(Long id);    User findByUsername(String username);    Set&lt;String&gt; getRoleNamesByUserId(Long userId);    Set&lt;String&gt; getPermissionsNameByRoleNames(@Param(&quot;roleNames&quot;) Set&lt;String&gt; roleNames);}</code></pre><p>在需要缓存的地方添加@Cacheable注解</p>]]></content>
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第一次使用七牛云存储</title>
      <link href="/2018/09/26/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/"/>
      <url>/2018/09/26/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<ul><li>问题<br>因为不同服务器之间需要使用同一个图片,一开始决定建一个ftp图片服务器,只是这个项目就是一个cms简单的系统,所以不想搞的那么麻烦.老大让我去看一下七牛,然后我就去研究了一下.</li><li><p>过程<br>首先打开七牛的官网,注册账号,绑定手机,然后就创建了一个存储空间.这个存储空间可以上传图片,然后你就可以获得一个关于这个图片的url地址,在你的网站上就可以使用这个地址读取这个图片,挺方便的.<br><img src="http://upload-images.jianshu.io/upload_images/1483237-0aefa5a0ba42bd47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160720174013.png"><br>接着就想怎么上传图片,在七牛官网上找了一会,然后就在个人面板上面找到了文档中心,接着就开始看帮助文档里面的快速入门,api文档,看了半天,有了一个大概的思路.<br>在上传的时候需要提供一个上传凭证,而这个凭证需要AccessKey/SecretKey这两个密钥来进行获取.而这两个密钥在个人面板-&gt;密钥管理里面,接着就看晕了.<br>后来就在网上找帖子,查资料,后来在一个帖子上看到一个人提供了链接,那个链接指向的是开发者资源,里面有关于java的SDK,然后就点进去了,发现TMD,原来Demo都在这里面,把maven的依赖拷进去,然后把他的demo也一块拷了进去,修改了密钥和存储仓库名称,设置上传图片文件和图片名称,测试上传图片,成功. </p><pre><code>&lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;7.0.0&lt;/version&gt; &lt;/dependency&gt;import com.qiniu.util.Auth;import java.io.IOException;import com.qiniu.common.QiniuException;import com.qiniu.http.Response;import com.qiniu.storage.UploadManager;public class UploadDemo {   //设置好账号的ACCESS_KEY和SECRET_KEY   String ACCESS_KEY = &quot;Access_Key&quot;;   String SECRET_KEY = &quot;Secret_Key&quot;; //要上传的空间   String bucketname = &quot;Bucket_Name&quot;; //上传到七牛后保存的文件名 String key = &quot;my-java.png&quot;; //上传文件的路径 String FilePath = &quot;/.../...&quot;; //密钥配置 Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY); //创建上传对象 UploadManager uploadManager = new UploadManager(); //简单上传，使用默认策略，只需要设置上传的空间名就可以了 public String getUpToken(){ return auth.uploadToken(bucketname); } public void upload() throws IOException{ try { //调用put方法上传 Response res = uploadManager.put(FilePath, key, getUpToken()); //打印返回的信息 System.out.println(res.bodyString()); } catch (QiniuException e) { Response r = e.response; // 请求失败时打印的异常的信息 System.out.println(r.toString()); try { //响应的文本信息 System.out.println(r.bodyString()); } catch (QiniuException e1) { //ignore } } } public static void main(String args[]) throws IOException{   new UploadDemo().upload();  }}</code></pre></li></ul><ul><li>总结<br>我是没想到七牛会把demo放在SDK下载的地方,一开始是想看在帮助文档里面找jav的SDK的使用,没想到没有.看来还得多看多尝试.          </li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java简单的爬虫(今日头条)</title>
      <link href="/2018/09/26/java%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
      <url>/2018/09/26/java%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB-%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/</url>
      <content type="html"><![CDATA[<p>之前在做资讯站的时候需要用到爬虫来获取一些文章,今天刚好有空就研究了一下.在网上看到了一个demo,使用的是Jsoup,我拿过来修改了一下,<br>由于今日头条的文章的特殊性,所以无法直接获取文章的地址,需要获取文章的id然后在拼接成url再访问.</p><pre><code>public class Demo2 { public static void main(String[] args) {    // 需要爬的网页的文章列表    String url = &quot;http://www.toutiao.com/news_finance/&quot;;    //文章详情页的前缀(由于今日头条的文章都是在group这个目录下,所以定义了前缀,而且通过请求获取到的html页面)    String url2=&quot;http://www.toutiao.com/group/&quot;;    //链接到该网站    Connection connection = Jsoup.connect(url);    Document content = null;    try {        //获取内容        content = connection.get();    } catch (IOException e) {        e.printStackTrace();    }    //转换成字符串    String htmlStr = content.html();    //因为今日头条的文章展示比较奇葩,都是通过js定义成变量,所以无法使用获取dom元素的方式获取值    String jsonStr = StringUtils.substringBetween(htmlStr,&quot;var _data = &quot;, &quot;;&quot;);    System.out.println(jsonStr);    Map parse = (Map) JSONObject.parse(jsonStr);    JSONArray parseArray = (JSONArray) parse.get(&quot;real_time_news&quot;);    Map map=null;    List&lt;Map&gt; maps=new ArrayList&lt;&gt;();    //遍历这个jsonArray,获取到每一个json对象,然后将其转换成Map对象(在这里其实只需要一个group_id,那么没必要使用map)    for(int i=0;i&lt;parseArray.size();i++){        map = (Map)parseArray.get(i);        maps.add((Map)parseArray.get(i));        System.out.println(map.get(&quot;group_id&quot;));    }    //遍历之前获取到的map集合,然后分别访问这些文章详情页    for (Map map2 : maps) {        connection = Jsoup.connect(url2+map2.get(&quot;group_id&quot;));        try {            Document document = connection.get();            //获取文章标题            Elements title = document.select(&quot;[class=article-title]&quot;);            System.out.println(title.html());            //获取文章来源和文章发布时间            Elements articleInfo = document.select(&quot;[class=articleInfo]&quot;);            Elements src = articleInfo.select(&quot;[class=src]&quot;);            System.out.println(src.html());            Elements time = articleInfo.select(&quot;[class=time]&quot;);            System.out.println(time.html());            //获取文章内容            Elements contentEle = document.select(&quot;[class=article-content]&quot;);            System.out.println(contentEle.html());        } catch (IOException e) {            e.printStackTrace();        }    } }}</code></pre>]]></content>
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从零开始netty学习笔记之protobuf</title>
      <link href="/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bprotobuf/"/>
      <url>/2018/09/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8Bnetty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bprotobuf/</url>
      <content type="html"><![CDATA[<p><code>LoginRequest.LoginCommand</code>的生成见<a href="http://www.jianshu.com/p/a36f31aa55de" target="_blank" rel="noopener">http://www.jianshu.com/p/a36f31aa55de</a><br>服务端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ProtobufServer &#123;</span><br><span class="line"></span><br><span class="line">    public void bind(int port) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        //配置服务端的NIO线程组</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">            b.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,1024)</span><br><span class="line">                    .handler(new LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufVarint32FrameDecoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufDecoder(LoginRequest.LoginCommand.getDefaultInstance()));</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufEncoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            //绑定端口，同步等待成功</span><br><span class="line">            ChannelFuture f= b.bind(port).sync();</span><br><span class="line">            //等待服务器监听端口关闭</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            //优雅退出，释放线程池资源</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        if(args!=null&amp;&amp;args.length&gt;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                port = Integer.valueOf(args[0]);</span><br><span class="line">            &#125;catch (NumberFormatException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        new ProtobufServer().bind(port);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ProtobufServerHandler extends ChannelHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        LoginRequest.LoginCommand command = (LoginRequest.LoginCommand) msg;</span><br><span class="line">        if(&quot;zml&quot;.equals(command.getUsername()))&#123;</span><br><span class="line">            System.out.println(&quot;服务器接收到的消息：&quot;+command.toString());</span><br><span class="line">            ctx.writeAndFlush(resp(command.getUsername()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LoginRequest.LoginCommand resp(String username) &#123;</span><br><span class="line">        LoginRequest.LoginCommand.Builder builder = LoginRequest.LoginCommand.newBuilder();</span><br><span class="line"></span><br><span class="line">        builder.setUsername(&quot;hello zml&quot;);</span><br><span class="line">        return builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel registed----&quot;);</span><br><span class="line">        super.channelRegistered(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;channel active----&quot;);</span><br><span class="line">        super.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class ProtobufClient &#123;</span><br><span class="line"></span><br><span class="line">    public void connect(int port,String host)throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        //配置客户端NIO线程组</span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line"></span><br><span class="line">            Bootstrap b = new Bootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY,true)</span><br><span class="line">                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufVarint32FrameDecoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufDecoder(LoginRequest.LoginCommand.getDefaultInstance()));</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufEncoder());</span><br><span class="line">                            socketChannel.pipeline().addLast(new ProtobufClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            //发起异步连接操作</span><br><span class="line">            ChannelFuture f= b.connect(host,port).sync();</span><br><span class="line">            //等待异步连接操作</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">            System.out.println(&quot;优雅关闭&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        if(args!=null&amp;&amp;args.length&gt;0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                port = Integer.valueOf(args[0]);</span><br><span class="line">            &#125;catch (NumberFormatException e)&#123;</span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                port = 8081;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        new ProtobufClient().connect(port,&quot;127.0.0.1&quot;);</span><br><span class="line">        System.out.println(&quot;启动完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ProtobufClientHandler extends ChannelHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;收到服务端的返回：&quot;+msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;第一次连接&quot;);</span><br><span class="line">        for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">            ctx.writeAndFlush(subReq(i));</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.flush();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LoginRequest.LoginCommand subReq(int i) &#123;</span><br><span class="line"></span><br><span class="line">        LoginRequest.LoginCommand.Builder builder = LoginRequest.LoginCommand.newBuilder();</span><br><span class="line">        builder.setUsername(&quot;zml&quot;);</span><br><span class="line">        return builder.build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ProtobufDecoder仅仅负责解码，它不支持读半包。因此，在ProtobufDecoder前面，一点要有能够读半包的解码器，有一下三种方式可以选择。</p><ul><li>使用Netty提供的ProtobufVarint32FrameDecoder，它可以处理半包消息。</li><li>继承Netty提供的通用半包解码器LengthFieldBasedFrameDecoder。</li><li>继承ByteToMessageDecoder类，自己处理半包消息。</li></ul><p>netty extend用法<br>tcp编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseCommand.HitCommand.Builder builder = BaseCommand.HitCommand.newBuilder();</span><br><span class="line">           builder.setDamage(10);</span><br><span class="line">           builder.setEnemyId(2);</span><br><span class="line">           builder.setId(1);</span><br><span class="line">           BaseCommand.HitCommand build = builder.build();</span><br><span class="line">           BaseCommand.ServerCommand.Builder builder1 = BaseCommand.ServerCommand.newBuilder();</span><br><span class="line">           builder1.setCommandType(BaseCommand.CommandType.Hit);</span><br><span class="line"></span><br><span class="line">           builder1.setExtension(BaseCommand.HitCommand.hitCommand,build);</span><br><span class="line"></span><br><span class="line">           channel.writeAndFlush(new DatagramPacket(Unpooled.copiedBuffer(builder1.build().toByteArray()),new InetSocketAddress(&quot;127.0.0.1&quot;,port)));</span><br></pre></td></tr></table></figure></p><p>解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf data = datagramPacket.content();</span><br><span class="line">        byte[] b = new byte[data.readableBytes()];</span><br><span class="line">        data.readBytes(b);</span><br><span class="line">        ExtensionRegistry registry = ExtensionRegistry.newInstance();</span><br><span class="line">        BaseCommand.registerAllExtensions(registry);</span><br><span class="line"></span><br><span class="line">        BaseCommand.ServerCommand serverCommand = BaseCommand.ServerCommand.parseFrom(b,registry);</span><br><span class="line">        System.out.println(&quot;commandType:&quot;+serverCommand.getCommandType());</span><br><span class="line">        BaseCommand.HitCommand extension = serverCommand.getExtension(BaseCommand.HitCommand.hitCommand);</span><br><span class="line">        System.out.println(&quot;damage:&quot;+extension.getDamage());</span><br><span class="line">        System.out.println(&quot;enemyId:&quot;+extension.getEnemyId());</span><br><span class="line">        System.out.println(&quot;id:&quot;+extension.getId());</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记五 Hystrix服务降级 Hystrix依赖隔离 断路器</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7-Hystrix%E4%BE%9D%E8%B5%96%E9%9A%94%E7%A6%BB-%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94-Hystrix%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7-Hystrix%E4%BE%9D%E8%B5%96%E9%9A%94%E7%A6%BB-%E6%96%AD%E8%B7%AF%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>###服务降级<br>在之前eureka-consumer的基础上<br>添加依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>Application<br>添加注解@EnableCircuitBreaker或者@EnableHystrix<br>或者只需要一个注解@SpringCloudApplication</p><p>service</p><pre><code>@Servicepublic class DemoService {    @Autowired    RestTemplate restTemplate;    @HystrixCommand(fallbackMethod = &quot;fallback&quot;)    public String hello(){        try {            //Thread.sleep(5000);        } catch (InterruptedException e) {            e.printStackTrace();        }        return restTemplate.getForObject(&quot;http://eureka-client/hello&quot;,String.class);    }    public String fallback(){        return &quot;fallback&quot;;    }}</code></pre><p>controller</p><pre><code>@GetMapping(&quot;/hello&quot;)public String hello2(){    return demoService.hello();}</code></pre><p>这样便实现了服务降级，将service中的Thread.sleep(5000)注释去掉，便可以模拟请求超时，系统便会调用fallback方法。</p><p>###依赖隔离</p><p>“舱壁模式”对于熟悉Docker的读者一定不陌生，Docker通过“舱壁模式”实现进程的隔离，使得容器与容器之间不会互相影响。而Hystrix则使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。</p><p>通过对依赖服务的线程池隔离实现，可以带来如下优势：</p><ul><li>应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。</li><li>可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。</li><li>当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。</li><li>当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。</li><li>当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。</li><li>除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。</li></ul><p>总之，通过对依赖服务实现线程池隔离，让我们的应用更加健壮，不会因为个别依赖服务出现问题而引起非相关服务的异常。同时，也使得我们的应用变得更加灵活，可以在不停止服务的情况下，配合动态配置刷新实现性能配置上的调整。</p><p>###断路器</p><p>当我们把服务提供者eureka-client中加入了模拟的时间延迟之后，在服务消费端的服务降级逻辑因为hystrix命令调用依赖服务超时，触发了降级逻辑，但是即使这样，受限于Hystrix超时时间的问题，我们的调用依然很有可能产生堆积。</p><p>这个时候断路器就会发挥作用，那么断路器是在什么情况下开始起作用呢？这里涉及到断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是：</p><ul><li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。<ul><li>请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。</li></ul></li><li>错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。</li></ul><p>那么当断路器打开之后会发生什么呢？我们先来说说断路器未打开之前，对于之前那个示例的情况就是每个请求都会在当hystrix超时之后返回fallback，每个请求时间延迟就是近似hystrix的超时时间，如果设置为5秒，那么每个请求就都要延迟5秒才会返回。当熔断器在10秒内发现请求总数超过20，并且错误百分比超过50%，这个时候熔断器打开。打开之后，再有请求调用的时候，将不会调用主逻辑，而是直接调用降级逻辑，这个时候就不会等待5秒之后才返回fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p><p>在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p><p>通过上面的一系列机制，hystrix的断路器实现了对依赖资源故障的端口、对降级策略的自动切换以及对主逻辑的自动恢复机制。这使得我们的微服务在依赖外部服务或资源的时候得到了非常好的保护，同时对于一些具备降级逻辑的业务需求可以实现自动化的切换与恢复，相比于设置开关由监控和运维来进行切换的传统实现方式显得更为智能和高效。</p><p>我们使用了@HystrixCommand来将某个函数包装成了Hystrix命令，这里除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离。所以，依赖隔离、服务降级在使用时候都是一体化实现的，这样利用Hystrix来实现服务容错保护在编程模型上就非常方便的，并且考虑更为全面。除了依赖隔离、服务降级之外，还有一个重要元素：断路器。这三个重要利器构成了Hystrix实现服务容错保护的强力组合拳。</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据库优化</title>
      <link href="/2018/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
      <url>/2018/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<ul><li>冗余<br>适当冗余可以降低多表查询，比较适合经常查询并且修改不多的数据。</li><li>索引<br>在经常查询的列上做索引，该列需要重复度比较低。</li><li>读写分离<br>mysql做主从，读写分离，在Master上面进行写操作，在Slave上面做读操作。</li><li>读写分离的瓶颈<br>写操作大于读操作，Master的写操作过多，并且Slave同步有延迟</li></ul>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>装饰者模式</title>
      <link href="/2018/09/26/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/26/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>装饰者模式-动态的将责任附加到对象上,想要扩展功能,装饰者提供有别于继承的另一种选择.<br>java 的io就是使用了装饰者模式.其中InputStream是一个抽象类,FileInputStream是InputStream的一个实现,而BufferdInputStream,LineNumberInputStream都是继承于FileInputStream.<br>装饰者模式就是将一个类传入到另一个类里面进行一些功能的增强,而且增强之后的类可以替换原来的类.</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springboot配置文件</title>
      <link href="/2018/09/26/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/09/26/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>###在配置文件中使用自定义参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myport=8080</span><br><span class="line">server.port=$&#123;myport&#125;</span><br></pre></td></tr></table></figure></p><p>###在代码里面使用自定义参数<br>通过注解<code>@Value</code>来加载自定义参数</p><ul><li>PlaceHolder方式 ${}  例@Value(“${abc}”)</li><li>SpEL方式  #{}  例@Value(“#{abc}”)</li></ul><p>###在配置文件中使用随机数</p><ul><li>随机字符串<br>com.zml.str=${random.value}</li><li>随机int<br>com.zml.intval=${random.int}</li><li>随机long<br>com.zml.longval=${random.long}</li><li>10以内的随机数<br>com.zml.intval=${random.int(10)}</li><li>10-20随机数<br>com.zml.intval=${random.int[10,20]}<br>###使用不同配置文件启动<br>创建一个简单的springboot应用<br>创建三个配置文件application.properties,application-dev.properties,application-test.properties</li></ul><p>application.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure></p><p>application-dev.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=config-client</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure></p><p>application-test.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=config-client</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure></p><p>启动之后，系统使用了8080端口启动，使用dev配置文件<br>在通过java -jar方式启动的时候，可以通过带参数，在启动的时候动态使用配置文件，不带参数，默认使用application.properties里面配置的配置文件</p><p><code>java -jar xxx.jar --spring.profiles.active=test</code></p><p>系统使用8081端口，使用test配置文件</p><p>###配置文件加载顺序<br>优先级由高到低</p><ul><li>在命令行中传入的参数</li><li>SPRING_APPLICATION_JSON中的属性。SPRING_APPLICATION_JSON是以json格式配置在系统环境变量中的内容</li><li>java:comp/env中的JNDI属性</li><li>java的系统属性，可以通过System.getProperties()获取的内容。</li><li>操作系统的环境变量</li><li>通过random.*配置的随机属性</li><li>位于当前应用jar包之外，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是yaml定义的配置文件</li><li>位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是yaml定义的配置文件</li><li>位于当前应用jar包之外，application.properties和yaml定义的配置文件</li><li>位于当前应用jar包之内，application.properties和yaml定义的配置文件</li><li>在@Configuration注解修改的类中，通过@PropertySource注解定义的属性</li><li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容</li></ul>]]></content>
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>netty消息分发思路</title>
      <link href="/2018/09/26/netty%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E6%80%9D%E8%B7%AF/"/>
      <url>/2018/09/26/netty%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E6%80%9D%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>首先在消息中定义一个关于消息的名称 比如login regist这种类似的。</p><p>然后使用spring，将一些处理类继承runnable接口，然后添加@component注解，并命名为相应的命令。</p><p>接着在接收到这个命令的时候，先获取命令，然后通过spring获取该命令的实例，接着放到一个线程池中运行。</p><p>在通过spring获取到这个实例时，将channel和消息都设置到处理逻辑实例中，方便想客户端返回一些字节流。</p>]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux学习笔记二</title>
      <link href="/2018/09/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2018/09/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h3 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h3><pre><code>linux具有为一个文件起多个名字的功能,称为链接.每个链接可以有不同的权限,不同的命名.</code></pre><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>ln默认创建硬链接</p><p>不能对目录文件创建硬链接<br>不能在不同的文件系统中之间做硬链接.就是说,链接文件和被链接文件必须位于同一个文件系统中.</p><h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接也成软链接,是将一个路径名链接到一个文件.这些文件是一种特别类型的文件.事实上,它只是一个文本文件,其中包含它提供链接的另一个文件的路径名.<br>与硬链接不同,符号链接确实是一个新文件,而硬链接并没有建立新文件.<br>符号链接没有硬链接的限制,可以对目录文件创建符号链接,也可以在不同文件系统之间建立符号链接.</p><p>符号链接保持了链接与源文件或目录之间的区别:</p><ul><li>删除源文件或目录,只删除数据,不会删除链接.一旦以同样文件创建源文件,链接将继续指向该文件的新数据.</li><li>在目录长列表中,符号链接以一种特殊的文件类型显示出来,其中第一个字母是l</li><li>符号链接的大小是其链接文件的路径名的字节数</li><li>当用ls -l命令列出文件时,可以看到符号链接名后有一个箭头指向源文件或目录 例:/root/test-&gt;/home/test</li></ul><h4 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h4><p>ln命令用来创建链接<br> -s,–symbolic 建立符号链接,而不是硬链接.<br> 符号链接文件不是一个独立的文件,它的许多属性依赖于源文件,所以给符号链接文件设置存取权限是没有意义的.</p><h3 id="关于用户和权限"><a href="#关于用户和权限" class="headerlink" title="关于用户和权限"></a>关于用户和权限</h3><h4 id="文件主"><a href="#文件主" class="headerlink" title="文件主"></a>文件主</h4><p>linux为每个文件都分配了一个文件所有者,即文件主,并赋予文件主唯一的注册名.对文件的控制取决于文件主或超级用户root</p><p>文件或目录的创建者对创建的文件或目录拥有特别的使用权.<br>文件的所有关系是可变的,可以将文件或目录的所有权装让给其他用户,但是只有文件主或root才有权改变文件的所有关系.文件所有权的标志的用户ID(UID)<br>利用chown命令可以修改文件或目录的文件主</p><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>当系统管理员为用户建立账号之后，会分配一个组ID和一个特定的用户组名。通常这些组名包含有相同需求的用户。采用组方式也有助于增强系统使用的安全性</p><p>虽然已经分配了一个标记注册组的组ID，但是该组也可以是其他组的成员。如果目前从事的项目涉及多个用户组，那么它可能不止属于属于一个组，从而可以与那些组中的用户共享信息。</p><p>在linux系统中，每个文件隶属于一个用户组。当创建一个文件或目录时，系统会赋予它一个用户组关系，用户组的所有成员都可以使用此文件或目录。<br>文件用户组关系的标志是GID。文件的GID只能由文件主或超级管理员来修改。利用chgrp命令可以改变文件的GID</p><h4 id="存取权限"><a href="#存取权限" class="headerlink" title="存取权限"></a>存取权限</h4><p>linux系统中的每个文件和目录都有存取许可权限。</p><p>linux系统规定了4中不同类型的用户。</p><ul><li>文件主owner</li><li>同组用户group</li><li>可以访问系统的其他用户others</li><li>超级用户root</li></ul><p>存取权限规定了三种访问文件或目录的方式</p><ul><li>读r</li><li>写w</li><li>可执行或可查询x</li></ul><p>使用ls -l 可以显示该文件或目录的权限<br>分别为 文件主权限，组用户权限，其他用户权限</p><h4 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h4><ul><li>以符号模式改变权限</li></ul><p>chmod key 文件名<br>key：[who] [操作符号] [mode]</p><p>who 操作对象可以是下面字母中的任一一个或者它们的组合<br>    u 用户user，即文件或目录的所有者<br>    g 同组group用户，即与文件主由相同组ID的所有用户<br>    o 其他用户others<br>    a 所有用户all，它是系统默认值</p><p>操作符 </p><pre><code>+ 添加某个权限- 取消某个权限= 富裕给定权限并取消其他所有权限（如果有的话）</code></pre><p>mode  所表示的权限可用下面字母的任意组合<br>    r 可读<br>    w 可写<br>    x 可执行<br>    X 只有目标文件对某些用户是可执行的，或该目标文件是目录时，才追加x（可执行）属性<br>    u 与文件主拥有一样的权限<br>    g 与文件主同组的用户拥有一样的权限<br>    o 与其他用户有用一样的权限</p><p>可以有多个key，但必须以逗号分隔开</p><p>chmod u=r，ug=x file</p><ul><li>以绝对方式改变权限 </li></ul><p>chmod mode 文件名</p><p>rwxrwxrwx 如果有权限，则为1没有则为0<br>rwxr-xr-x 111101101表示755 文件主有读写执行权限，组用户和其他用户拥有读，执行权利</p><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>列出每个与当前shell有关的进程的基本信息</p><p>PID TTY TIME CMD</p><pre><code>PID 进程标志号TTY 该进程建立时所对应的终端,&quot;?&quot; 表示该经常不占用终端TIME 报告进程累计使用的CPU时间.注意,尽管有些命令(如sh)已经运转了很长时间,但是它们真正使用CPU的时间往往很短.所以该字段的值往往是00:00:00CMD 执行进程的命令名,是command的缩写</code></pre><p>ps -ef </p><pre><code>显示系统中所有进程的全面信息</code></pre><p>UID PID PPID C STIME TTY TIME CMD</p><pre><code>UID 进程属主的用户idPPID 父进程的ID号C 进程最近使用CPU的估算STIME 进程开始时间,以&quot;小时:分&quot;的形式给出</code></pre><p>ps aux<br>显示所有终端上所有用户的有关进程的所有信息</p><p>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p><pre><code>USER 启动进程的用户%CPU 运行该进程占用CPU的时间与该进程总运行时间的比例%MEM 该进程占用内存和总内存的比例VSZ 虚拟内存的大小,以KB为单位RSS 任务使用的不被交换物理内存的数量,以KB为单位STAT 用多个字符表示进程的运行状态,其中包括以下几种代码</code></pre><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>用来终止一个进程的运行</p><ul><li>-s 指定需要发送的信号,该信号既可以是信号名,也可以是对应信号的号码</li><li>-p 指定kill命令只是显示进程的PID 并不是真正发出结束信号</li><li>-l 显示信号名称列表,</li></ul><p>kill命令可以带信号选项,也可以不带.如果没有带信号号码,kill命令就会发出终止信号(TERM),该信号可以被进程捕获,是进程在退出之前清理并释放资源.</p><p>普通用户只能使用不带信号参数的kill命令或至多使用信号9</p><p>只有万不得已时,才用kill信号(9)</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux学习笔记一</title>
      <link href="/2018/09/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/09/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><pre><code>显示文件内容</code></pre><ul><li><p>-b 从1开始对所有非空输出行进行编号</p></li><li><p>-n 从1开始对所有输出行进行编号</p></li><li><p>ctrl+s停止滚屏</p></li><li><p>ctrl+q恢复滚屏</p></li><li><p>ctrl+c终止命令的执行</p><pre><code>cat file1 file2 同时显示文件file1和file2的内容 cat file1 file2 &gt; file3 将文件file1和file2合并后放入文件file3</code></pre><h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><p> 在屏幕上显示指定文件的末尾若干行<br> tail命令在屏幕上显示指定文件的末尾10行.</p><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p> 修改指定文件的时间标签,或者创建一个空文件.</p><p> touch命令将会修改指定文件的时间标签,把已存在文件的时间标签更新为系统当前的时间,它们的数据将原封不动的保留下来.如果该文件尚未存在,则创建一个空的新文件.</p><ul><li><p>-m 仅改变指定文件的存取时间</p></li><li><p>-c 不创建任何文件</p></li><li><p>-m 仅改变指定文件的修改时间</p></li></ul><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p> 该命令在文本文件中查找指定模式的词或短语,并在标准输出设备上显示包括给定字符串模式的所有行.</p><p> 该命令组包含三个命令:grep,egrep,fgrep命令.grep命令一次只能搜索一个指定的模式,egrep等同于grep -E,可以使用扩展的字符串模式进行搜索,fgrep命令等同于grep -F,是快速搜索命令,它检索固定字符串,但不识别正则表达式</p><ul><li><p>-c 只显示文件中包含匹配字符串的行的总数</p></li><li><p>-i  不识别大小写</p></li><li><p>-R ,-r 以递归的方式查询目录下的所有子目录中的文件</p></li><li><p>-n 在输出匹配模式的行之前,加上该行的行号(从1开始)</p></li><li><p>-v 只显示不包含匹配字符串的文本行</p></li><li><p>-x 只显示整个行都严格匹配的行</p></li></ul><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p> 将源文件或目录复制到目标文件或目录中</p><p> 如果是复制目录,则需要加 -r参数 递归的将该目录下的所有文件复制到目标目录</p><ul><li><p>-a 该选项通常在复制目录时使用.它递归的将源目录下的所有子目录及其文件都复制到目标目录中,并且保留文件链接和文件属性不变.它等效于-dpR.</p></li><li><p>-d 复制时保留文件链接</p></li><li><p>-f ,–force 如果现存文件不能打开,则删除它并且重试一次.</p></li></ul></li><li><p>-i, –interactive,与-f选项不同,在覆盖目标文件之前先给出提示,要求用户予以确认,交互式复制</p><ul><li>-p 除复制源文件的内容外,还将其修改时间和存取权限也复制到新文件中.</li></ul></li><li><p>-R,-r 递归复制目录,即将源目录下的所有文件及其各级子目录都复制到目标位置</p></li><li><p>-l 不复制,而是创建指向源文件的链接文件,链接文件名由目标文件给出.</p><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>移动文件或者重命名文件</p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除文件或目录</p><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>创建目录</p></li><li><p>-m,–mode=MODE 将新建目录的存取权限设置为MODE,存取权限用给定的八进制数字表示</p></li><li><p>-p,-parents 可一次建立多个目录,如果新建目录所指定的路径中有些父目录不存在,则此选项可以自动建立它们.</p></li><li><p>mkdir -p -m 750 test/test2</p><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><p> 删除空的目录</p><ul><li>-p,–parents 递归删除目录</li></ul><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p> 显示出当前工作目录的绝对路径</p></li></ul><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><pre><code>如果给出的参数是目录,该命令将列出其中所有子目录与文件的信息;如果给出的参数是文件,将列出有关该文件属性的一些信息.默认情况下,输出条目按字母顺序排列.如果没有给出参数,将显示当前目录下所有子目录和文件的信息.</code></pre><ul><li><p>-l</p><p> 以长格式显示文件的详细信息.输出的信息分成多列,他们依次是:</p><p> 文件类型与权限 链接数 文件主 文件组 文件大小 建立或最近修改的时间 文件名</p><p> -rw-r–r– 1 root root 0 2月 18 20:59 file1</p><p> 其中几个字段的含义说明:</p><ul><li><p>第一个字段中第一个字符表示文件类型,所用字符及其含义是:</p><ul><li>- 普通文件</li><li>d 目录</li><li>b 块设备文件</li><li>c 字符设备文件</li><li>l 符号链接文件</li></ul></li><li><p>随后的9个字符表示文件的存取权限.各权限字符表示如下:</p><ul><li>r 读</li><li>w 写</li><li>x 执行,对于目录,表示可以用访问该目录</li><li>s 当文件被执行时,把该文件的UID或GID赋予执行进程的UID(用户ID)或GID(组ID)</li><li>- 表示没设置权限 </li></ul></li><li><p>对于符号链接文件,在最后”文件名”字段显示的形式是:</p><p>  符号链接文件名-&gt;目标文件的路径名</p></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>activemq的ObjectMessage的安全问题</title>
      <link href="/2018/09/26/activemq%E7%9A%84ObjectMessage%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/26/activemq%E7%9A%84ObjectMessage%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>在使用activemq的对象消息ObjectMessage的时候,报了一个错误,在对获得的对象进行强转的时候,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javax.jms.JMSException: Failed to build body from content. Serializable class not available to broker. Reason: java.lang.ClassNotFoundException: Forbidden class com.ssp.common.tools.CommonObjectMessage! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.</span><br><span class="line">    at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:36)</span><br><span class="line">    at org.apache.activemq.command.ActiveMQObjectMessage.getObject(ActiveMQObjectMessage.java:208)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">在网上搜索的解决方案:</span><br><span class="line"></span><br><span class="line">将ActiveMQConnectionFactory注入两个参数中的其中一个就行</span><br></pre></td></tr></table></figure><property name="trustedPackages"><br>    <list><br>        <value>org.apache.activemq.test</value><br>        <value>org.apache.camel.test</value><br>    </list><br></property><br><property name="trustAllPackages" value="true"></property><p><code>`</code><br>用的activemq-all版本是5.11.3,尝试注入上述的两个参数,进入ActiveMQConnectionFactory这个类里面发现并没有上述的两个对象.然后将activemq-all版本换成5.14.2,问题解决.</p>]]></content>
      
      <categories>
          
          <category> activemq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> activemq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 安装jdk</title>
      <link href="/2018/09/26/linux%20%E5%AE%89%E8%A3%85jdk/"/>
      <url>/2018/09/26/linux%20%E5%AE%89%E8%A3%85jdk/</url>
      <content type="html"><![CDATA[<ul><li>使用yum 安装jdk</li><li>使用tar.gz文件解压安装jdk</li></ul><p>配置环境变量</p><p>vim /etc/profile</p><p>在尾部添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_60</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用openssl生成rsa公钥和私钥</title>
      <link href="/2018/09/26/%E4%BD%BF%E7%94%A8openssl%E7%94%9F%E6%88%90rsa%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5/"/>
      <url>/2018/09/26/%E4%BD%BF%E7%94%A8openssl%E7%94%9F%E6%88%90rsa%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5/</url>
      <content type="html"><![CDATA[<p>生成一个名为rsa_private_key.pem的私钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rsa_private_key.pem 1024</span><br></pre></td></tr></table></figure></p><p>将私钥转换成pkcs8格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -nocrypt -inform PEM -in rsa_private_key.pem -outform PEM</span><br></pre></td></tr></table></figure></p><p>需要自己手动保存</p><p>生成rsa_public_key.pem公钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用Intellij创建springboot项目Spring Initializr Error 403</title>
      <link href="/2018/09/26/%E4%BD%BF%E7%94%A8Intellij%E5%88%9B%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AESpring-Initializr-Error-403/"/>
      <url>/2018/09/26/%E4%BD%BF%E7%94%A8Intellij%E5%88%9B%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AESpring-Initializr-Error-403/</url>
      <content type="html"><![CDATA[<p>使用Spring Initializr创建项目时报错<br><img src="https://user-gold-cdn.xitu.io/2018/5/4/1632a39080f92029?w=1314&amp;h=568&amp;f=jpeg&amp;s=62843" alt=""></p><p>修改Intellij代理设置</p><p>在这里,我自己开启了ss,查看ss监听的地址和端口号,然后设置到Intellij中<br><img src="https://user-gold-cdn.xitu.io/2018/5/4/1632a3a79d6e426e?w=2204&amp;h=1352&amp;f=jpeg&amp;s=236072" alt=""></p><p>创建项目成功<br><img src="https://user-gold-cdn.xitu.io/2018/5/4/1632a3b9713ba8d1?w=1896&amp;h=1172&amp;f=jpeg&amp;s=134536" alt=""></p>]]></content>
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关闭tomcat报错Cannot allocate memory</title>
      <link href="/2018/09/26/%E5%85%B3%E9%97%ADtomcat%E6%8A%A5%E9%94%99Cannot-allocate-memory/"/>
      <url>/2018/09/26/%E5%85%B3%E9%97%ADtomcat%E6%8A%A5%E9%94%99Cannot-allocate-memory/</url>
      <content type="html"><![CDATA[<p>报错如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">90 #   CATALINA_PID    (Optional) Path of the file which should contains the pid</span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /root/software/jdk1.8.0_131</span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000080000000, 348913664, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12)</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 348913664 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># /usr/local/tomcat/hs_err_pid23927.log</span><br><span class="line">Kill failed: $CATALINA_PID not set</span><br></pre></td></tr></table></figure></p><p>主要是系统内存不够,无法分配内存了</p><p>解决方案:<br>修改./bin/catalina.sh中的内存分配<br>将最小内存修改到系统剩余内存以内</p><p><code>JAVA_OPTS=&quot; -server -Xms256M -Xmx2048M</code></p>]]></content>
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树java实现</title>
      <link href="/2018/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91java%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91java%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>二叉树节点的定义:</p><pre><code>public class BinaryNode {    Object element;        //节点存储的值    BinaryNode left;    //左孩子    BinaryNode right;    //右孩子}</code></pre><p>定义二叉查找树:</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记七 高可用注册中心</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>###介绍<br>Eureka Server除了单点运行之外，还可以通过运行多个实例，并进行互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署。</p><p>创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer2和peer3</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=peer1server.port=1111#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/,http://peer3:1113/eureka/management.security.enabled=false</code></pre><p>创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer1和peer3</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=peer2server.port=1112#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://peer3:1113/eureka/,http://peer1:1111/eureka/management.security.enabled=false</code></pre><p>创建application-peer3.properties，作为peer3服务中心的配置，并将serviceUrl指向peer1和peer2</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=peer3server.port=1113#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/,http://peer1:1111/eureka/management.security.enabled=false</code></pre><p>将其打成jar包<br>执行<code>java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1</code><br><code>java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2</code><br><code>java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer3</code></p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记八 消息总线</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/</url>
      <content type="html"><![CDATA[<p>###springboot整合RabbitMQ</p><ul><li>安装rabbitmq</li><li>进入cmd进入D:\RabbitMQ Server\rabbitmq_server-3.6.10\sbin</li><li>执行rabbitmq-plugins enable rabbitmq_management</li><li>打开浏览器并访问：<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></li><li>默认账户密码都为guest</li></ul><p>创建项目<br>依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=rabbitmq-demo</span><br><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=123456</span><br></pre></td></tr></table></figure><p>消息生产者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Sender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context = &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息消费者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;hello&quot;)</span><br><span class="line">public class Receiver &#123;</span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>rabbit配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Application<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class HelloApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = Application.class)</span><br><span class="line">public class ApplicationTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Sender sender;</span><br><span class="line">    @Test</span><br><span class="line">    public void hello() throws Exception &#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###springcloud整合RabbitMQ使用消息总线更新配置文件</p><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置文件添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=123456</span><br></pre></td></tr></table></figure><p>发送post请求到localhost:2001/bus/refresh便可以刷新所有服务的配置</p><p>####原理分析<br>我们通过使用Spring Cloud Bus与Spring Cloud Config的整合，并以RabbitMQ作为消息代理，实现了应用配置的动态更新。<br><img src="http://blog.didispace.com/assets/5-6.png" alt="abc"></p><p>整个方案的架构如上图所示，其中包含了Git仓库、Config Server、以及微服务“Service A”的三个实例，这三个实例中都引入了Spring Cloud Bus，所以他们都连接到了RabbitMQ的消息总线上。</p><p>当我们将系统启动起来之后，“Service A”的三个实例会请求Config Server以获取配置信息，Config Server根据应用配置的规则从Git仓库中获取配置信息并返回。</p><p>此时，若我们需要修改“Service A”的属性。首先，通过Git管理工具去仓库中修改对应的属性值，但是这个修改并不会触发“Service A”实例的属性更新。我们向“Service A”的实例3发送POST请求，访问/bus/refresh接口。此时，“Service A”的实例3就会将刷新请求发送到消息总线中，该消息事件会被“Service A”的实例1和实例2从总线中获取到，并重新从Config Server中获取他们的配置信息，从而实现配置信息的动态更新。</p><p>而从Git仓库中配置的修改到发起/bus/refresh的POST请求这一步可以通过Git仓库的Web Hook来自动触发。由于所有连接到消息总线上的应用都会接受到更新请求，所以在Web Hook中就不需要维护所有节点内容来进行更新，从而解决了通过Web Hook来逐个进行刷新的问题。</p><p>####指定刷新范围<br>上面的例子中，我们通过向服务实例请求Spring Cloud Bus的/bus/refresh接口，从而触发总线上其他服务实例的/refresh。但是有些特殊场景下（比如：灰度发布），我们希望可以刷新微服务中某个具体实例的配置。</p><p>Spring Cloud Bus对这种场景也有很好的支持：/bus/refresh接口还提供了destination参数，用来定位具体要刷新的应用程序。比如，我们可以请求/bus/refresh?destination=customers:9000，此时总线上的各应用实例会根据destination属性的值来判断是否为自己的实例名，若符合才进行配置刷新，若不符合就忽略该消息。</p><p>destination参数除了可以定位具体的实例之外，还可以用来定位具体的服务。定位服务的原理是通过使用Spring的PathMatecher（路径匹配）来实现，比如：/bus/refresh?destination=customers:**，该请求会触发customers服务的所有实例进行刷新。</p><p>####架构优化</p><p>既然Spring Cloud Bus的/bus/refresh接口提供了针对服务和实例进行配置更新的参数，那么我们的架构也相应的可以做出一些调整。在之前的架构中，服务的配置更新需要通过向具体服务中的某个实例发送请求，再触发对整个服务集群的配置更新。虽然能实现功能，但是这样的结果是，我们指定的应用实例就会不同于集群中的其他应用实例，这样会增加集群内部的复杂度，不利于将来的运维工作，比如：我们需要对服务实例进行迁移，那么我们不得不修改Web Hook中的配置等。所以我们要尽可能的让服务集群中的各个节点是对等的。</p><p>因此，我们将之前的架构做了一些调整，如下图所示：</p><p><img src="http://blog.didispace.com/assets/5-7.png" alt=""></p><p>我们主要做了这些改动：</p><ul><li>在Config Server中也引入Spring Cloud Bus，将配置服务端也加入到消息总线中来。</li><li>/bus/refresh请求不在发送到具体服务实例上，而是发送给Config Server，并通过destination参数来指定需要更新配置的服务或实例。</li></ul><p>通过上面的改动，我们的服务实例就不需要再承担触发配置更新的职责。同时，对于Git的触发等配置都只需要针对Config Server即可，从而简化了集群上的一些维护工作。</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ribbon</title>
      <link href="/2018/09/26/Ribbon/"/>
      <url>/2018/09/26/Ribbon/</url>
      <content type="html"><![CDATA[<p>在springcloud中，引入Ribbon来作为客户端时，负载均衡使用的是被<code>@LoadBalanced</code>修饰的<code>RestTemplate</code>对象。</p><p>####RestTemplate详细的用法</p><ul><li><p>GET请求</p><p>第一种方式<br>返回ResponseEntity，该对象是Spring对HTTP请求响应的封装，其中主要存储了HTTP的几个重要元素，HttpStatus代表了错误码如404,500等。以及HttpHeaders代表了请求头，body代表了接收到的对象，其类型是根据第二个参数决定的。第一个url为请求地址，可以使用{1}占位符，而参数的值在该方法的最后的可变参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(&quot;http://eureka-client/hello&quot;,String.class);</span><br><span class="line">String body = forEntity.getBody();</span><br><span class="line">HttpHeaders headers = forEntity.getHeaders();</span><br><span class="line">HttpStatus statusCode = forEntity.getStatusCode();</span><br></pre></td></tr></table></figure></li></ul><p>三个重载方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getForEntity(String url,Class responseType,Object... urlVariables);</span><br><span class="line">getForEntity(String url,Class responseType,Map urlVariables);</span><br><span class="line">getForEntity(URI url,Class responseType);</span><br></pre></td></tr></table></figure></p><p>第二种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String forObject = restTemplate.getForObject(&quot;http://eureka-client/hello&quot;, String.class);</span><br></pre></td></tr></table></figure></p><p>第二种方式与第一种方式唯一的不同就是getForObject的返回值类型直接就是参数列表的第二个参数指定的类型，所以这种方式没法获取错误码和请求头等信息。</p><p>RestTemplate本来是Spring提供的发送REST请求的工具类，但是当其被@LoadBalanced注解修饰后，通过其发送REST请求，会被LoadBalanceInterceptor类的inteceptor拦截，然后进行一些负载均衡和请求地址的转换。</p><p>####负载均衡策略<br>通过继承AbstractLoadBalancerRule抽象类来具体实现负载均衡策略。<br>RandomRule<br>通过随机服务实例的数量来产生一个随机数，通过索引获取该服务实例</p><p>RoundRobinRule<br>按照线性轮询的方式依次选择每个服务实例的功能<br>RetryRule<br>该策略实现了一个具备重试机制的实例选择功能。其内部还定义了一个IRule对象，默认使用RoundRobinRule实例。在choose方法中则实现了对内部定义的策略进行反复尝试的策略，若期间能够选择到具体的服务实例就返回，若选择不到就根据设置的尝试结束时间为阀值（maxRetryMillis参数定义的值+choose方法开始执行是的时间戳），当超过该值后就返回null<br>WeightedResponseTimeRule<br>该策略是对RoundRobinRule的扩展，增加了根据实例的运行情况来计数权重，并根据权重来挑选实例。该策略实例化的时候在内部创建了一个定时任务，每过30s便去统计一下各个实例的权重。<br>ClientConfigEnableRoundRobinRule<br>该策略较为特殊，一般不直接使用它。该策略内部定义了一个RoundRobinRule策略，choose函数的实现也是使用了RoundRobinRule的线下轮询机制。一般使用方法：继承该策略，默认的choose方法实现了线性轮询机制，在子类中做一些高级策略时通常可能会存在一些无法实施的情况，那么就可以用父类的实现作为备选。<br>BestAvailableRule<br>该策略继承ClientConfigEnableRoundRobinRule，在实现中它注入了负载均衡器的统计对象LoadBalancerStats，同时在具体的choose算法中利用LoadBalancerStats保存的实例统计信息来满足要求的实例。它通过遍历负载均衡器中维护的所有服务实例，会过滤掉故障的实例，并找出并发请求数最少的一个，所以该策略的特性是可选出最空闲的实例。<br>PredicateBasedRule<br>抽象策略，继承了ClientConfigEnableRoundRobinRule，基于Predicate实现的策略，Predicate是Google Guava Collection工具对集合进行过滤的条件接口，策略：先过滤清单，在轮询选择</p><p>AvailableFilteringRule<br>继承自PredicationBasedRule</p><p>ZoneAvoidanceRule<br>继承自PredicationBasedRule</p><p>####重试<br>spring cloud eureka比较注重可用性，所以在极端情况下，它宁愿接收故障实例也不会丢掉“健康”实例，比如当服务注册中心的网络发生故障断开时，由于所有的服务实例无法持续维持心跳，一般的服务治理会将所有的服务实例剔除，但是eureka则会因为超过85%的实例丢失心跳而触发保护机制，注册中心将会保留此时的所有节点，以实现服务间依然可以进行互相调用的场景，即使其中有部分故障节点，但这样做可以继续保障大多数的服务正常消费。<br>由于spring cloud eureka咋可用性与一致性上的取舍，所以我们在实现服务调用的时候通常会加入一些重试机制。spring cloud 整合了spring retry来增强RestTemplate的重试能力，只需通过简单的配置，原来那些通过RestTemplate实现的服务访问就会自动根据配置来实现重试策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.loadbalancer.retry.enabled=true</span><br><span class="line">#开启重试机制</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000</span><br><span class="line">#断路器的超时时间需要大于Ribbon的超时时间，不然不会触发重试</span><br><span class="line">eureka-consumer.ribbon.ConnectTimeout=250</span><br><span class="line">#请求连接的超时时间</span><br><span class="line">eureka-consumer.ribbon.ReadTimeout=1000</span><br><span class="line">#请求处理的超时时间</span><br><span class="line">eureka-consumer.ribbon.OkToRetryOnAllOperations=true</span><br><span class="line">#对所有操作请求都进行重试</span><br><span class="line">eureka-consumer.ribbon.MaxAutoRetriesNextServer=2</span><br><span class="line">#切换实例的重试次数</span><br><span class="line">eureka-consumer.ribbon.MaxAutoRetries=1</span><br><span class="line">#对当前实例的重试次数</span><br></pre></td></tr></table></figure></p><p>当访问到故障请求的时候，它会在尝试访问一次当前实例（次数由MaxAutoRetries配置），如果不行，就换一个实例进行访问，如果还是不行，在换一次实例访问（更换次数由MaxAutoRetriesNextServer配置），如果依然不行，在返回失败信息。</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>游戏服务器分析</title>
      <link href="/2018/09/26/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/26/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>ServerServiceManager服务启动管理器，单例，包含一个Map<string serviceid,iservice="">  方法：注册服务，获取服务，移除服务</string></p><p>GlobalManager  各种全局的业务管理器、公共服务实例的持有者，负责各种管理器的初始化和实例的获取</p><p>LocalNetService  本地网络服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GameServer server = new GameServer();</span><br><span class="line"></span><br><span class="line">       super(ServerServiceManager.SERVICE_ID_ROOT);</span><br><span class="line">       this.globalManager = new GlobalManager();</span><br><span class="line">       this.localNetService = new LocalNetService();</span><br><span class="line"></span><br><span class="line">server.startServer();</span><br><span class="line">    输出日志：服务器启动中</span><br><span class="line">    init(configFile);</span><br><span class="line">        initSpring();   初始化spring容器</span><br><span class="line">        globalManager.init(configFile);</span><br><span class="line">            //从spring中获取localSpringBeanManager的实例，然后设置到LocalMananger里面的localSpringBeanManager成员变量中。localSpringServiceManager，localSpringServicerAfterManager</span><br><span class="line">            initLocalManger();</span><br><span class="line">            //初始化本地服务// //初始化game-excutor更新服务</span><br><span class="line">            initLocalService();</span><br><span class="line"></span><br><span class="line">           //初始化消息处理器</span><br><span class="line">           //根据使用的协议的不同，初始化tcp和udp处理队列    gameTcpMessageProcessor，GameUdpMessageOrderProcessor，并将其添加到LocalMananger中</span><br><span class="line">           initNetMessageProcessor();</span><br><span class="line">           //扩展使用（没有内容）</span><br><span class="line">           initGameManager();</span><br><span class="line">    start();</span><br><span class="line">          //根据更新器执行类型启动更新服务updateService.start();</span><br><span class="line">          globalManager.start();</span><br><span class="line">          //首先初始化处理器initChannelInitializer();根据 GameServerConfig，创建GameNettyTcpServerService，GameNettyUdpServerService，GameNettyRPCService</span><br><span class="line">          localNetService.startup();</span><br><span class="line">          //创建服务器启动结束服务 并调用启动startup方法，并且添加到了LocalManager中</span><br><span class="line">          LocalMananger.getInstance().create(GamerServerStartFinishedService.class, GamerServerStartFinishedService.class);</span><br><span class="line">           //注册停服监听器，用于执行资源的销毁等停服时的处理工作</span><br><span class="line">          addShutdownHook();</span><br><span class="line">          //游戏服务器运行时数据，打开服务</span><br><span class="line">         GameServerRuntime.setOpenOn();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    输出日志：服务器启动成功,正在运行</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>redis简单的操作</title>
      <link href="/2018/09/26/redis%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/09/26/redis%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>常用数据结构<br>redis简单操作</p><pre><code>public class Test1 {    @Test    public void test() {        Jedis jedis = new Jedis(&quot;192.168.1.96&quot;);        String zml = jedis.get(&quot;zml&quot;);        System.out.println(zml);        if(zml==null){            jedis.set(&quot;zml&quot;, &quot;zhumeilu&quot;);        }        System.out.println(jedis.get(&quot;zml&quot;));    }}</code></pre><p>redis池化</p><p>配置文件</p><pre><code>#最大分配的对象数  redis.pool.maxActive=1024#最大能够保持idel状态的对象数  redis.pool.maxIdle=200#当池内没有返回对象时，最大等待时间  redis.pool.maxWait=1000#当调用borrow Object方法时，是否进行有效性检查  redis.pool.testOnBorrow=true#当调用return Object方法时，是否进行有效性检查  redis.pool.testOnReturn=true#IP  redis.ip=192.168.1.96#Port  redis.port=6379</code></pre><p>创建一个redis池工具类</p><pre><code>public class RedisClient {    private static JedisPool pool;    static{        ResourceBundle bundle = ResourceBundle.getBundle(&quot;redis&quot;);        if(bundle==null){            throw new RuntimeException(&quot;reids.propertis为空&quot;);        }        System.out.println(bundle);        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxActive(Integer.valueOf(bundle.getString(&quot;redis.pool.maxActive&quot;)));        config.setMaxIdle(Integer.valueOf(bundle.getString(&quot;redis.pool.maxIdle&quot;)));        config.setMaxWait(Integer.valueOf(bundle.getString(&quot;redis.pool.maxWait&quot;)));        config.setTestOnBorrow(Boolean.valueOf(bundle.getString(&quot;redis.pool.testOnBorrow&quot;)));        config.setTestOnBorrow(Boolean.valueOf(bundle.getString(&quot;redis.pool.testOnReturn&quot;)));        pool = new JedisPool(config, bundle.getString(&quot;redis.ip&quot;));    }    public static JedisPool getPool() {        return pool;    }}</code></pre><p>通过JedisPool获取jedis实例</p><pre><code>public class TestPool {    @Test    public void test() {        JedisPool pool = RedisClient.getPool();        Jedis jedis = pool.getResource();        System.out.println(jedis);        String zml = jedis.get(&quot;zml&quot;);        System.out.println(zml);        pool.returnResource(jedis);    }}</code></pre>]]></content>
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring配置RoutingDataSource实现mysql读写分离</title>
      <link href="/2018/09/26/Spring%E9%85%8D%E7%BD%AERoutingDataSource%E5%AE%9E%E7%8E%B0mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2018/09/26/Spring%E9%85%8D%E7%BD%AERoutingDataSource%E5%AE%9E%E7%8E%B0mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      <content type="html"><![CDATA[<p>首先我们先配置两个数据源：</p><pre><code>&lt;!-- 1:数据源 --&gt;&lt;bean id=&quot;masterDs&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;    destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;slaveDs&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;    destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc2.driverClassName}&quot; /&gt;    &lt;property name=&quot;url&quot; value=&quot;${jdbc2.url}&quot; /&gt;    &lt;property name=&quot;username&quot; value=&quot;${jdbc2.username}&quot; /&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc2.password}&quot; /&gt;&lt;/bean&gt;</code></pre><p>接着<br>org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource是一个路由分发数据源，负责对数据源的切换。由于它是抽象的，我们需要自己写一个类来继承它，并且实现里面的抽象方法。</p><pre><code>public class P2PDataSource extends AbstractRoutingDataSource{        //这个方法返回当前使用数据源的名称        //DataSourceContext里面有一个线程变量，用来设置和获取当前线程也就是当前这个请求使用的数据源是哪一个    @Override    protected Object determineCurrentLookupKey() {        if(DataSourceContext.get()==null){            return null;        }        if(DataSourceContext.get().equals(BidConst.MASTER_DATASOURCE)){            return &quot;masterDs&quot;;        }else{            return &quot;slaveDs&quot;;        }    }}</code></pre><p>数据源上下文：用来存储当前请求的数据源名称</p><pre><code>public class DataSourceContext {    private static ThreadLocal&lt;String&gt; dataSource=new ThreadLocal&lt;&gt;();    public static void set(String dataSource){        DataSourceContext.dataSource.set(dataSource);                }    public static String get(){        return DataSourceContext.dataSource.get();    }}</code></pre><p>配置路由数据源</p><pre><code>&lt;!-- 配置路由分发DataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.xmg.p2p.base.util.P2PDataSource&quot;&gt;    &lt;property name=&quot;targetDataSources&quot;&gt;        &lt;map&gt;            &lt;entry key=&quot;master&quot; value-ref=&quot;masterDs&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;slave&quot; value-ref=&quot;slaveDs&quot;&gt;&lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=&quot;defaultTargetDataSource&quot; ref=&quot;masterDs&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>最后在需要读的serviceImpl的方法里面先设置数据源：<br>DataSourceContext.dataSource.set(“slaveDs”);<br>然后在进行读的操作。</p>]]></content>
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shardingjdbc+spring使用路由数据源支持DISTINCT</title>
      <link href="/2018/09/26/shardingjdbc-spring%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90%E6%94%AF%E6%8C%81DISTINCT/"/>
      <url>/2018/09/26/shardingjdbc-spring%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90%E6%94%AF%E6%8C%81DISTINCT/</url>
      <content type="html"><![CDATA[<p>大概思路就是使用AbstractRoutingDataSource来动态切换数据源，当需要使用DISTINCT的时候，切换成功原生数据源，来进行查询。在这里还需要自己根据自定义的规则查询表名。</p><p>原生数据源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;nativeDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span><br><span class="line">init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;db.master.url&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;db.master.user&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;db.master.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>sharingjdbc数据源，内部还是引用了原生数据源的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;sharding:data-source id=&quot;shardingDataSource&quot;&gt;</span><br><span class="line">    &lt;sharding:sharding-rule data-source-names=&quot;nativeDataSource&quot;&gt;</span><br><span class="line">        &lt;sharding:table-rules&gt;</span><br><span class="line">            &lt;sharding:table-rule logic-table=&quot;apply_order&quot; actual-data-nodes=&quot;nativeDataSource.apply_order_$&#123;[2017,2018]&#125;$&#123;1..54&#125;&quot; table-strategy-ref=&quot;orderTableShardingStrategy&quot; /&gt;</span><br><span class="line">            &lt;sharding:table-rule logic-table=&quot;apply_device&quot; actual-data-nodes=&quot;nativeDataSource.apply_device_$&#123;[2017,2018]&#125;$&#123;1..54&#125;&quot; table-strategy-ref=&quot;applyDeviceTableShardingStrategy&quot; /&gt;</span><br><span class="line">            &lt;sharding:table-rule logic-table=&quot;awake_request_record&quot; actual-data-nodes=&quot;nativeDataSource.awake_request_record_$&#123;[2017,2018]&#125;$&#123;1..12&#125;&quot; table-strategy-ref=&quot;awakeRequestRecordTableShardingStrategy&quot; /&gt;</span><br><span class="line">        &lt;/sharding:table-rules&gt;</span><br><span class="line">        &lt;sharding:binding-table-rules&gt;</span><br><span class="line">            &lt;sharding:binding-table-rule logic-tables=&quot;apply_order,apply_device,awake_request_record&quot;/&gt;</span><br><span class="line">        &lt;/sharding:binding-table-rules&gt;</span><br><span class="line">    &lt;/sharding:sharding-rule&gt;</span><br><span class="line">    &lt;sharding:props&gt;</span><br><span class="line">        &lt;prop key=&quot;sql.show&quot;&gt;true&lt;/prop&gt;</span><br><span class="line">    &lt;/sharding:props&gt;</span><br><span class="line">&lt;/sharding:data-source&gt;</span><br></pre></td></tr></table></figure><p>路由数据源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;dataSource&quot; class=&quot;com.dsp.common.datasource.DynamicDataSource&quot; &gt;</span><br><span class="line">&lt;!-- 已配置的数据源 --&gt;</span><br><span class="line">&lt;property name=&quot;targetDataSources&quot;&gt;</span><br><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry key=&quot;shardingDataSource&quot; value-ref=&quot;shardingDataSource&quot;/&gt;</span><br><span class="line">&lt;entry key=&quot;nativeDataSource&quot; value-ref=&quot;nativeDataSource&quot;/&gt;</span><br><span class="line">&lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 默认的数据源 --&gt;</span><br><span class="line">&lt;property name=&quot;defaultTargetDataSource&quot; ref=&quot;shardingDataSource&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>接着在mybatis引用数据源的地方使用这个路由数据源</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shardingjdbc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记一 服务注册中心</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      <content type="html"><![CDATA[<h3 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h3><ul><li><p>添加依赖</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Dalston.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li><li><p>配置文件</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=localhostserver.port=1111#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false</code></pre></li><li><p>Application.java</p><pre><code>@EnableEurekaServer //启动一个服务注册中心提供给其他应用进行对话@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }}</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用谷歌云服务开启8080等其他的端口</title>
      <link href="/2018/09/26/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF8080%E7%AD%89%E5%85%B6%E4%BB%96%E7%9A%84%E7%AB%AF%E5%8F%A3/"/>
      <url>/2018/09/26/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF8080%E7%AD%89%E5%85%B6%E4%BB%96%E7%9A%84%E7%AB%AF%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>最近使用朋友的谷歌云服务器，发现无法开启8080等一些端口，查了很多资料，也改了防火墙之类的都没有效果，最后翻墙google了一下，找到了解决方案。</p><p>登录谷歌云服务器</p><ul><li>查询所有防火墙规则<pre><code>gcloud compute firewall-rules list</code></pre></li><li>创建一个名为allow-ssr，端口号为1099的规则<pre><code>gcloud compute firewall-rules create allow-ssr --allow tcp:1099</code></pre></li><li>删除一个名为allow-ssr的防火墙规则<pre><code>gcloud compute firewall-rules delete allow-ssr</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>nginx配置文件</title>
      <link href="/2018/09/26/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/09/26/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>nginx的启动：nginx<br>重启：nginx -s reload<br>快读关闭： nginx -s stop<br>安全关闭：nginx -s quit</p><p>nginx配置文件：</p><pre><code>server {    #监听80端口    listen       80;     #服务器的名称    server_name  localhost;     #访问日志   日志格式main需要在前面定义    access_log  logs/host.access.log  main;     #location / 代表匹配根路径下的所有资源   location后面跟一个正则表达式，用来匹配请求的资源。    location / {             #资源文件加载的根路径，一些静态资源文件，如静态的html，js，css，图片等。        root   html;         #首页默认页面        index  index.html index.htm;       }    #以jsp结尾的资源文件，proxy_pass   http://127.0.0.1代表转发给http://127.0.0.1     location ~ .*.jsp$ {        proxy_pass   http://127.0.0.1;    }    #禁止访问WEB-INF里面的文件    location ~ ^/WEB-INF/ {        deny  all;    }    # 错误404页面    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #服务器错误500页面    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   html;    }}      </code></pre><p>为上面这些配置文件单独命名，比如<a href="http://www.zhumeilu.me.conf" target="_blank" rel="noopener">www.zhumeilu.me.conf</a> 保存在nginx.conf同级目录或者自己创建一个子目录，然后在nginx.conf的http里面添加一行，也就是代替了原来的server{}，这样做的好处可以分开管理多个服务器</p><pre><code>include www.zhumeilu.me.conf</code></pre><p>nginx的负载均衡：<br>分配策略：</p><ul><li>轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</li><li>weight<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</li><li><p>ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  </p></li><li><p>fair<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。 </p></li><li><p>url_hash<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。<br>修改配置文件：</p><pre><code>#定义负载均衡设备的 ip及设备状态 upstream myServer {    server localhost:8080;  server localhost:8081;  server localhost:8082;  server localhost:8083;  ip_hash;}server { location ~ .*.jsp$ {      proxy_pass   http://myServer;  }}</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql中文乱码</title>
      <link href="/2018/09/26/mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/09/26/mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<ul><li>最近项目中遇到了中文乱码，一开始以为是编码过滤器没有配置好路径，接着debug后发现前天传到后天的数据没有乱码。</li><li>那么就是数据存到数据库的过程中出现了问题，我清楚的记得我创建数据库的时候指定了utf8的编码，所以应该不是这个问题。</li><li><p>那么就是连接数据库的时候出的问题了，接着百度了一下，在连接的url里面加上了两个参数useUnicode=true&amp;characterEncoding=utf-8，然后问题解决。</p><p>  //连接地址：<br>  jdbc:mysql://127.0.0.1:3306/abc?useUnicode=true&amp;characterEncoding=utf-8</p></li></ul>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql性能优化</title>
      <link href="/2018/09/26/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/09/26/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h4 id="MYSQL执行SQL的流程"><a href="#MYSQL执行SQL的流程" class="headerlink" title="MYSQL执行SQL的流程"></a>MYSQL执行SQL的流程</h4><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db90b967e9396?w=462&amp;h=364&amp;f=png&amp;s=72990" alt="image.png"></p><p>SQL的执行过程； </p><ol><li>客户端发送一条查询给服务器； </li><li>服务器通过权限检查之后,先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段； </li><li>服务器端进行SQL解析、预处理，再由优化器根据该SQL所涉及到的数据表的统计信息进行计算，生成对应的执行计划； </li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询； </li><li>将结果返回给客户端。 </li></ol><p>SQL执行的最大瓶颈在于磁盘的IO，即数据的读取；不同SQL的写法，会造成不同的执行计划的执行，而不同的执行计划在IO的上面临完全不一样的数量级，从而造成性能的差距； 所以,我们说,优化SQL,其实就是让查询优化器根据程序猿的计划选择匹配的执行计划,来减少查询中产生的IO;</p><h4 id="schema-表结构-对性能的影响"><a href="#schema-表结构-对性能的影响" class="headerlink" title="schema(表结构)对性能的影响"></a>schema(表结构)对性能的影响</h4><ol><li><p>冗余数据的处理；<br>适当的数据冗余可以提高系统的整体查询性能(在P2P中,在userinfo对象中有realname和idnumber); 关系数据库的三范式: 第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库，是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值； 第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。 第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 (不允许有冗余数据) </p></li><li><p>大表拆小表，有大数据的列单独拆成小表； </p><ol><li>在一个数据库中,一般不会设计属性过多的表; </li><li>在一个数据库中,一般不会有超过500/1000万数据的表(拆表,按照逻辑拆分,按照业务拆分); <ol start="3"><li>有大数据的列单独拆成小表(富文本编辑器,CKeditor); </li></ol></li></ol></li><li><p>根据需求的展示设置更合理的表结构； </p></li><li><p>把常用属性分离成小表；</p><ol><li>在P2P项目中,我们把logininfo和userinfo和account表拆成了三张表; </li><li>减少查询常用属性需要查询的列; </li><li>便于常用属性的集中缓存;</li></ol></li></ol><p>####索引和索引的优化:<br>1,索引的原理:把无序的数据变成有序的查询;</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db90b9681b189?w=884&amp;h=456&amp;f=png&amp;s=121073" alt="image.png"></p><h4 id="索引"><a href="#索引" class="headerlink" title="索引:"></a>索引:</h4><ol><li><p>索引的物理结构: </p><ol><li>数据库文件存储的位置:my.ini配置文件中dataDir对应的数据目录中; </li><li>每一个数据库一个文件夹; <ol><li>MYISAM引擎:每一个表(table_name)–&gt;<br>table_name.MYI:存放的是数据表对应的索引信息和索引内容;<br>table_name.FRM:存放的是数据表的结构信息;<br>table_name.MYD:存放的是数据表的内容; </li><li>InnoDB引擎:每一个表(table_name)–&gt;<br>table_name.frm:存放的是数据表的结构信息;<br>数据文件和索引文件都是统一存放在ibdata文件中; </li><li>索引文件都是额外存在的,对索引的查询和维护都是需要消耗IO的; </li></ol></li></ol></li><li><p>索引的结构:</p><ol><li>默认情况下,一旦创建了一个表,这个表设置了主键,那么MYSQL会自动的为这个主键创建一个unique的索引;</li><li>索引类型: <ol><li>Normal:普通的索引;允许一个索引值后面关联多个行值; </li><li>UNIQUE:唯一索引;允许一个索引值后面只能有一个行值;之前对列添加唯一约束其实就是为这列添加了一个unique索引;当我们为一个表添加一个主键的时候,其实就是为这个表主键列(设置了非空约束),并为主键列添加了一个唯一索引; </li><li>Fulltext:全文检索,mysql的全文检索只能用myisam引擎,并且性能较低,不建议使用; </li></ol></li><li>索引的方法(规定索引的存储结构): (数据结构,算法基础) <ol><li>b-tree:是一颗树(二叉树,平衡二叉树,平衡树(B-TREE)) 使用平衡树实现索引，是mysql中使用最多的索引类型；在innodb中，存在两种索引类型，第一种是主键索引（primary key），在索引内容中直接保存数据的地址；第二种是其他索引，在索引内容中保存的是指向主键索引的引用；所以在使用innodb的时候，要尽量的使用主键索引，速度非常快； b-tree中保存的数据都是按照一定顺序保存的数据,是可以允许在范围之内进行查询; select * from accountflow where account_id &lt;100;<ol start="2"><li>hash:把索引的值做hash运算，并存放到hash表中，使用较少，一般是memory引擎使用；优点:因为使用hash表存储，按照常理，hash的性能比B-TREE效率高很多。<br>hash索引的缺点：<br>1，hash索引只能适用于精确的值比较，=，in，或者&lt;&gt;；无法使用范围查询;<br>2，无法使用索引排序；<br>3，组合hash索引无法使用部分索引；<br>4，如果大量索引hash值相同，性能较低；</li></ol></li></ol></li></ol></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db90b9690ce7a?w=388&amp;h=294&amp;f=png&amp;s=6473" alt="image.png"></p><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db90b96926c32?w=391&amp;h=299&amp;f=png&amp;s=28041" alt="image.png"></p><h4 id="索引的利弊"><a href="#索引的利弊" class="headerlink" title="索引的利弊:"></a>索引的利弊:</h4><ol><li>索引的好处：<br>1，提高表数据的检索效率；<br>2，如果排序的列是索引列(如果查询的列==排序的列[并且在这列上做了索引])，大大降低排序成本；<br>3，在分组操作中如果分组条件是索引列，也会提高效率； </li><li>索引的问题： 索引需要额外的维护成本；因为索引文件是单独存在的文件,对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率; </li><li>怎么创建索引? <ol><li>较频繁的作为查询条件的字段应该创建索引； </li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件； 作为索引的列,如果不能有效的区分数据,那么这个列就不适合作为索引列;比如(性别,状态不多的状态列)<br>举例:SELECT sum(amount) FROM accountflow WHERE accountType = 0; 假如把accountType作为索引列,因为accountType只有14种,所以,如果根据accountType来创建索引,最多只能按照1/14的比例过滤掉数据;但是,如果可能出现,只按照该条件查询,那我们就要考虑到其他的提升性能的方式了;<br>第一种方案:单独创建一个系统摘要表;在这个里面有一个列叫做系统总充值金额;每次充值成功,增加这个列的值;以后要查询系统总充值金额,只需要从这个系统摘要表中查询;(缺陷:如果充值频率过快,会导致表的锁定问题;)<br>第二种方案:流水一旦发生了,是不会随着时间改变的;针对这种信息,我们就可以使用增量查询(结算+增量查询);<br>1,创建一张日充值表;记录每一天的充值总金额(beginDate,endDate,totalAmount),每天使用定时器对当前的充值记录进行结算;日充值报表里面记录只能记录截止昨天的数据;<br>2,创建一张月充值表;记录每一个月的充值总金额(beginDate,endDate,totalAmount),每月最后一天使用定时器对当月的充值记录进行结算(数据源从日充值报表来);<br>3,要查询系统总充值,从月报表中汇总(当前月之前的总充值金额),再从日充值报表中查询当天之前的日报表数据汇总;再从流水中查询当前截止查询时间的流水;使用另外一张当天流水表记录当天的流水;再把三个数据累加; </li><li>更新非常频繁的字段不适合创建索引；原因,索引有维护成本; </li><li>不会出现在WHERE 子句中的字段不该创建索引； </li><li>索引不是越多越好;(只为必要的列创建索引)<br>1,不管你有多少个索引,一次查询至多采用一个索引;(索引和索引之间是独立的)<br>2,因为索引和索引之间是独立的,所以说每一个索引都应该是单独维护的;数据的增/改/删,会导致所有的索引都要单独维护; <h4 id="索引的使用限制"><a href="#索引的使用限制" class="headerlink" title="索引的使用限制:"></a>索引的使用限制:</h4></li></ol></li><li>BLOB 和TEXT 类型的列只能创建前缀索引 </li><li>MySQL 目前不支持函数索引(在MYSQL中,索引只能是一个列的原始值,不能把列通过计算的值作为索引); 实例:请查询1981年入职的员工: SELECT <em> FROM emp WHERE year(hire_date)=’1981’; 问题:查询的列是在过滤之前经过了函数运算;所以,就算hire_date作为索引,year(hire_date)也不会使用索引; 解决方案: 1,SELECT </em> FROM emp WHERE hire_date BETWEEN ‘1981-01-01’ AND ‘1981-12-31’; 2,在创建一列,这列的值是year(hire_date),然后把这列的值作为索引; 3. 使用不等于（!= 或者&lt;&gt;）的时候MySQL 无法使用索引 </li><li>过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引]</li><li>Join 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引 </li><li>使用LIKE 操作的时候如果条件以通配符开始（ ‘%abc…’）MySQL 无法使用索引 1,字符串是可以用来作为索引的; 2,字符串创建的索引按照字母顺序排序; 3,如果使用LIKE,实例:SELECT * FROM userinfo WHERE realName LIKE ‘吴%’;这种情况是可以使用索引的; 但是LIKE ‘_嘉’ 或者LIKE ‘%嘉’都是不能使用索引的; </li><li>使用非等值查询的时候MySQL 无法使用Hash 索引 </li></ol><h4 id="单列索引和复合索引"><a href="#单列索引和复合索引" class="headerlink" title="单列索引和复合索引:"></a>单列索引和复合索引:</h4><ol><li>因为一个查询一次至多只能使用一个索引,所以,如果都使用单值索引(一个列一个索引),在数据量较大的情况下,不能很好的区分数据; </li><li>所以,MYSQL引入了多值索引(复合索引); 复合索引就是由多列的值组成的索引;并且(注意),多列的索引是有顺序的!!!! </li><li>复合索引的原理:就是类似orderby(orderby后面可以跟多个排序条件order by hire_date,username desc); 就是在排序和分组(创建倒排表的时候),按照多个列进行排序和合并;<br>SELECT <em> FROM accountflow WHERE actionTime &lt; ‘xxxxx’ AND account_id = 5 可以使用actionTime+account_id的复合索引;<br>SELECT </em> FROM accountflow WHERE actionTime &lt; ‘xxxxx’ 可以使用actionTime+account_id的复合索引; SELECT <em> FROM accountflow WHERE account_id = 5 不可以使用actionTime+account_id的复合索引; SELECT </em> FROM accountflow WHERE account_id = 5 AND actionTime &lt; ‘xxxxx’ 不可以使用actionTime+account_id的复合索引; </li><li>复合索引,在查询的时候,遵守向左原则;只要在查询的时候,是按照复合索引从左到右的顺序依次查询,不管查询条件是否完全满足所有的符合索引的列,都可以使用部分的符合索引; </li><li>在实际应用中,基本上都使用复合索引; </li></ol><h4 id="查看MYSQL的执行计划和执行明细状态-explain-profiling"><a href="#查看MYSQL的执行计划和执行明细状态-explain-profiling" class="headerlink" title="查看MYSQL的执行计划和执行明细状态(explain+profiling)"></a>查看MYSQL的执行计划和执行明细状态(explain+profiling)</h4><ol><li>Explain:可以让我们查看MYSQL执行一条SQL所选择的执行计划； </li><li>Profiling:可以用来准确定位一条SQL的性能瓶颈； </li></ol><h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN:"></a>EXPLAIN:</h4><ol><li>使用方式： explain SQL;</li><li>返回结果： <ol><li>ID：执行查询的序列号； </li><li>select_type：使用的查询类型 <ol><li>DEPENDENT SUBQUERY：子查询中内层的第一个SELECT，依赖于外部查询的结果集；</li><li>DEPENDENT UNION：子查询中的UNION，且为UNION 中从第二个SELECT 开始的后面所有SELECT，同样依赖于外部查询的结果集；</li><li>PRIMARY：子查询中的最外层查询，注意并不是主键查询； </li><li>SIMPLE：除子查询或者UNION 之外的其他查询； </li><li>SUBQUERY：子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集； </li><li>UNCACHEABLE SUBQUERY：结果集无法缓存的子查询； </li><li>UNION：UNION 语句中第二个SELECT 开始的后面所有SELECT，第一个SELECT 为PRIMARY 8，UNION RESULT：UNION 中的合并结果； </li></ol></li><li>table：这次查询访问的数据表； </li><li>type：对表所使用的访问方式： <ol><li>all：全表扫描</li><li>const：读常量，且最多只会有一条记录匹配，由于是常量，所以实际上只需要读一次； </li><li>eq_ref：最多只会有一条匹配结果，一般是通过主键或者唯一键索引来访问； </li><li>fulltext：全文检索，针对full text索引列； </li><li>index：全索引扫描； </li><li>index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行merge 之后再读取表数据； </li><li>index_subquery：子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或者唯一索引； </li><li>rang：索引范围扫描； </li><li>ref：Join 语句中被驱动表索引引用查询； </li><li>ref_or_null：与ref 的唯一区别就是在使用索引引用查询之外再增加一个空值的查询； </li><li>system：系统表，表中只有一行数据； </li><li>unique_subquery：子查询中的返回结果字段组合是主键或者唯一约束； </li></ol></li><li>possible_keys：可选的索引；如果没有使用索引，为null； </li><li>key：最终选择的索引； </li><li>key_len：被选择的索引长度； </li><li>ref：过滤的方式，比如const（常量），column（join），func（某个函数）； </li><li>rows：查询优化器通过收集到的统计信息估算出的查询条数； </li><li>Extra：查询中每一步实现的额外细节信息 <ol><li>Distinct：查找distinct 值，所以当mysql 找到了第一条匹配的结果后，将停止该值的查询而转为后面其他值的查询； </li><li>Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用使用； </li><li>Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果； </li><li>No tables：Query 语句中使用FROM DUAL 或者不包含任何FROM 子句； <ol start="5"><li>Not exists：在某些左连接中MySQL Query Optimizer 所通过改变原有Query 的组成而使用的优化方法，可以部分减少数据访问次数； </li><li>Select tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段的时候，MySQL Query Optimizer 会通过索引而直接一次定位到所需的数据行完成整个查询。当然，前提是在Query 中不能有GROUP BY 操作。如使用MIN()或者MAX（）的时候；</li><li>Using filesort：当我们的Query 中包含ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。 </li><li>Using index：所需要的数据只需要在Index 即可全部获得而不需要再到表中取数据； </li><li>Using index for group-by：数据访问和Using index 一样，所需数据只需要读取索引即可，而当Query 中使用了GROUP BY 或者DISTINCT 子句的时候，如果分组字段也在索引中，Extra 中的信息就会是Using index for group-by；               </li><li>Using temporary：当MySQL 在某些操作中必须使用临时表的时候，在Extra 信息中就会出现Using temporary 。主要常见于GROUP BY 和ORDER BY 等操作中。 </li><li>Using where：如果我们不是读取表的所有数据，或者不是仅仅通过索引就可以获取所有需要的数据，则会出现Using where 信息； </li><li>Using where with pushed condition：这是一个仅仅在NDBCluster 存储引擎中才会出现的信息，而且还需要通过打开Condition Pushdown 优化功能才可能会被使用。控制参数为engine_condition_pushdown 。 </li></ol></li></ol></li></ol></li></ol><h4 id="profiling"><a href="#profiling" class="headerlink" title="profiling:"></a>profiling:</h4><p> Query Profiler是MYSQL5.1之后提供的一个很方便的用于诊断Query执行的工具，能够准确的获取一条查询执行过程中的CPU，IO等情况；</p><pre><code>1. 开启profiling：set profiling=1; 2. 执行QUERY，在profiling过程中所有的query都可以记录下来； 3. 查看记录的query：show profiles； 4. 选择要查看的profile：show profile cpu, block io for query 6</code></pre><p> status是执行SQL的详细过程；<br>Duration：执行的具体时间；<br>CPU_user：用户CPU时间；<br>CPU_system：系统CPU时间；<br>Block_ops_in：IO输入次数；<br>Block_ops_out：IO输出次数；<br>profiling只对本次会话有效；</p><h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN:"></a>JOIN:</h4><p>1,JOIN的原理: 在mysql中使用Nested Loop Join来实现join； A JOIN B：通过A表的结果集作为循环基础，一条一条的通过结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果； 2,JOIN的优化原则: 1，尽可能减少Join 语句中的Nested Loop 的循环总次数，用小结果集驱动大结果集； 2，优先优化Nested Loop 的内层循环； 3，保证Join 语句中被驱动表上Join 条件字段已经被索引； 4，扩大join buffer的大小；</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/28/161db90b96d20dec?w=902&amp;h=416&amp;f=png&amp;s=266075" alt="image.png"></p><h3 id="SQL优化原则"><a href="#SQL优化原则" class="headerlink" title="SQL优化原则:"></a>SQL优化原则:</h3><h4 id="原则一-选择需要优化的SQL"><a href="#原则一-选择需要优化的SQL" class="headerlink" title="[原则一:选择需要优化的SQL]"></a>[原则一:选择需要优化的SQL]</h4><ol><li>选择需要优化的SQL:不是所有的SQL都需要优化,在优化的过程中,首选更需要优化的SQL; 怎么选择?<br>优先选择优化高并发低消耗的SQL； <ol><li>1小时请求1W次，1次10个IO； </li><li>1小时请求10次，1次1W个IO；<br>考虑: </li></ol><ul><li>从单位时间产生的IO总数来说,相同的; </li><li>针对一个SQL,如果我能把10个IO变成7个IO,一小时减少3W个IO; 针对第二个SQL,如果能把1W个IO变成7K个IO,一小时减少3W个IO; </li><li>从优化难度上讲,1W-&gt;7K难的多; </li><li>从整体性能上来说,第一个SQL的优化能够极大的提升系统整体的性能;第二个SQL慢一点,无非也就是10个连接查询慢一点; </li></ul></li><li>定位性能瓶颈； <ol><li>SQL运行较慢有两个影响原因，IO和CPU，明确性能瓶颈所在； </li><li>明确优化目标；<h4 id="原则二-从Explain和Profile入手"><a href="#原则二-从Explain和Profile入手" class="headerlink" title="[原则二:从Explain和Profile入手]"></a>[原则二:从Explain和Profile入手]</h4></li></ol></li><li>任何SQL的优化，都从Explain语句开始；Explain语句能够得到数据库执行该SQL选择的执行计划； </li><li>首先明确需要的执行计划，再使用Explain检查； </li><li>使用profile明确SQL的问题和优化的结果； <h4 id="原则三-永远用小结果集驱动大的结果集"><a href="#原则三-永远用小结果集驱动大的结果集" class="headerlink" title="[原则三:永远用小结果集驱动大的结果集]"></a>[原则三:永远用小结果集驱动大的结果集]</h4><h4 id="原则四-在索引中完成排序"><a href="#原则四-在索引中完成排序" class="headerlink" title="[原则四:在索引中完成排序]"></a>[原则四:在索引中完成排序]</h4><h4 id="原则五-使用最小Columns"><a href="#原则五-使用最小Columns" class="headerlink" title="[原则五:使用最小Columns]"></a>[原则五:使用最小Columns]</h4></li><li>减少网络传输数据量； </li><li>特别是需要使用column排序的时候.为什么?MYSQL排序原理，是把所有的column数据全部取出，在排序缓存区排序，再返回结果；如果column数据量大，排序区容量不够的时候，就会使用先column排序，再取数据，再返回的多次请求方式； <h4 id="原则六-使用最有效的过滤条件"><a href="#原则六-使用最有效的过滤条件" class="headerlink" title="[原则六:使用最有效的过滤条件]"></a>[原则六:使用最有效的过滤条件]</h4></li><li>过多的WHERE条件不一定能够提高访问性能； </li><li>一定要让where条件使用自己预期的执行计划； <h4 id="原则七-避免复杂的JOIN和子查询"><a href="#原则七-避免复杂的JOIN和子查询" class="headerlink" title="[原则七:避免复杂的JOIN和子查询]"></a>[原则七:避免复杂的JOIN和子查询]</h4></li><li>复杂的JOIN和子查询，需要锁定过多的资源，MYSQL在大量并发情况下处理锁定性能下降较快； </li><li>不要过多依赖SQL的功能，把复杂的SQL拆分为简单的SQL； </li><li>MySQL子查询性能较低，应尽量避免使用；</li></ol>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mongodb学习笔记一</title>
      <link href="/2018/09/26/mongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/09/26/mongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>首先引入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">MongoClient mc = null;</span><br><span class="line">MongoDatabase database = null;</span><br><span class="line">MongoCollection&lt;Document&gt; collection = null;</span><br><span class="line">@Before</span><br><span class="line">public void before()&#123;</span><br><span class="line">    //建立一个连接</span><br><span class="line">    mc = new MongoClient(&quot;localhost&quot;,27017 );</span><br><span class="line">    //获取一个数据库</span><br><span class="line">    database = mc.getDatabase(&quot;mydb&quot;);</span><br><span class="line">    //获取一个集合</span><br><span class="line">    collection = database.getCollection(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void insert()&#123;</span><br><span class="line">    //创建一个文档</span><br><span class="line">    Document doc = new Document(&quot;name&quot;, &quot;MongoDB&quot;)</span><br><span class="line">            .append(&quot;type&quot;, &quot;database&quot;)</span><br><span class="line">            .append(&quot;count&quot;, 1)</span><br><span class="line">            .append(&quot;versions&quot;, Arrays.asList(&quot;v3.2&quot;, &quot;v3.0&quot;, &quot;v2.6&quot;))</span><br><span class="line">            .append(&quot;info&quot;, new Document(&quot;x&quot;, 203).append(&quot;y&quot;, 102));</span><br><span class="line">    //插入一个文档</span><br><span class="line">    collection.insertOne(doc);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void insertMany()&#123;</span><br><span class="line">    //插入多个文档</span><br><span class="line">    List&lt;Document&gt; documents = new ArrayList&lt;Document&gt;();</span><br><span class="line">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        documents.add(new Document(&quot;i&quot;, i));</span><br><span class="line">    &#125;</span><br><span class="line">    collection.insertMany(documents);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void count()&#123;</span><br><span class="line">    //集合长度</span><br><span class="line">    System.out.println(&quot;集合长度：&quot;+collection.count());</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public  void firstQuery()&#123;</span><br><span class="line">    //获取集合第一个文档</span><br><span class="line">    Document myDoc = collection.find().first();</span><br><span class="line">    System.out.println(myDoc.toJson());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void allQuery()&#123;</span><br><span class="line">    //遍历集合，获取每个文档</span><br><span class="line">    MongoCursor&lt;Document&gt; cursor = collection.find().iterator();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (cursor.hasNext()) &#123;</span><br><span class="line">            System.out.println(cursor.next().toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void allQuery2()&#123;</span><br><span class="line">    //遍历集合，获取每个文档</span><br><span class="line">    //官方不推荐这种用法</span><br><span class="line">    for (Document cur : collection.find()) &#123;</span><br><span class="line">        System.out.println(cur.toJson());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void allQuery3()&#123;</span><br><span class="line">    //遍历集合，获取每个文档,分页</span><br><span class="line">    //skip()方法默认参数为 0 </span><br><span class="line">    MongoCursor&lt;Document&gt; cursor = collection.find().skip(10).limit(5).iterator();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (cursor.hasNext()) &#123;</span><br><span class="line">            System.out.println(cursor.next().toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void eq()&#123;</span><br><span class="line"></span><br><span class="line">    //查询i=100的文档</span><br><span class="line">    Document myDoc = collection.find(Filters.eq(&quot;i&quot;, 100)).first();</span><br><span class="line">    System.out.println(myDoc.toJson());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void gt()&#123;</span><br><span class="line">    //查询i&gt;50</span><br><span class="line">    Block&lt;Document&gt; printBlock = new Block&lt;Document&gt;() &#123;</span><br><span class="line">        public void apply(final Document document) &#123;</span><br><span class="line">            System.out.println(document.toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    collection.find(Filters.gt(&quot;i&quot;, 50)).forEach(printBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void between()&#123;</span><br><span class="line">    //查询i&gt;=50 and i&lt;=100</span><br><span class="line">    Block&lt;Document&gt; printBlock = new Block&lt;Document&gt;() &#123;</span><br><span class="line">        public void apply(final Document document) &#123;</span><br><span class="line">            System.out.println(document.toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    collection.find(Filters.and(gte(&quot;i&quot;, 50), Filters.lte(&quot;i&quot;, 100))).forEach(printBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void updateOne()&#123;</span><br><span class="line"></span><br><span class="line">    collection.updateOne(Filters.eq(&quot;i&quot;, 10), new Document(&quot;$set&quot;, new Document(&quot;i&quot;, 110)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void updateMany()&#123;</span><br><span class="line">    UpdateResult updateResult = collection.updateMany(Filters.lt(&quot;i&quot;, 100), Updates.inc(&quot;i&quot;, 100));</span><br><span class="line">    System.out.println(updateResult.getModifiedCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void deleteOne()&#123;</span><br><span class="line">    collection.deleteOne(Filters.eq(&quot;i&quot;, 110));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void deleteBetween()&#123;</span><br><span class="line">    DeleteResult deleteResult = collection.deleteMany(Filters.gte(&quot;i&quot;, 100));</span><br><span class="line">    System.out.println(deleteResult.getDeletedCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void addIndex()&#123;</span><br><span class="line">    collection.createIndex(new Document(&quot;i&quot;, 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac下安装配置nginx</title>
      <link href="/2018/09/26/mac%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnginx/"/>
      <url>/2018/09/26/mac%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnginx/</url>
      <content type="html"><![CDATA[<p>因为mac自带apache2的原因，所以80端口被占用，而安装的nginx默认使用8080端口。<br>因为之前安装过了homebrew，所以使用homebrew安装nginx，这样也比较方便。<br>直接在终端运行brew install nginx就可以了。默认安装完的nginx路径为/usr/local/etc/nginx，页面的加载地址为/usr/local/var/www<br>在终端运行nginx，然后nginx就启动了。<br>接着在浏览器中输入localhost:8080就可以看到nginx已经运行。</p>]]></content>
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shardingjdbc分表分库，主从分离</title>
      <link href="/2018/09/26/shardingjdbc%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/"/>
      <url>/2018/09/26/shardingjdbc%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/</url>
      <content type="html"><![CDATA[<p>使用shardingjdbc需要修改mybatis的数据源。原来是mybatis直接引用dataSource，现在需要将dataSource注入到shardingjdbc，然后在将shardingjdbc的shardingDataSource注入给mybatis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--数据源--&gt;</span><br><span class="line">&lt;bean name=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span><br><span class="line">init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;db.master.url&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;db.master.user&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;db.master.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>对apply_orde，apply_device这两张表进行分表，按createtime进行分表，每周分一张表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--shardingjdbc的规则--&gt;</span><br><span class="line">&lt;sharding:standard-strategy id=&quot;orderTableShardingStrategy&quot; sharding-column=&quot;createtime&quot; range-algorithm-class=&quot;com.dsp.common.algorithm.RangleTableShardingAlgorithm&quot; precise-algorithm-class=&quot;com.dsp.common.algorithm.PreciseTableShardingAlgorithm&quot;/&gt;</span><br><span class="line">    &lt;sharding:standard-strategy id=&quot;applyDeviceTableShardingStrategy&quot; sharding-column=&quot;createtime&quot; range-algorithm-class=&quot;com.dsp.common.algorithm.RangleTableShardingAlgorithm&quot; precise-algorithm-class=&quot;com.dsp.common.algorithm.PreciseTableShardingAlgorithm&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sharding:data-source id=&quot;shardingDataSource&quot;&gt;</span><br><span class="line">        &lt;sharding:sharding-rule data-source-names=&quot;dataSource&quot;&gt;</span><br><span class="line">            &lt;sharding:table-rules&gt;</span><br><span class="line">                &lt;sharding:table-rule logic-table=&quot;apply_order&quot; actual-data-nodes=&quot;dataSource.apply_order_2017$&#123;1..54&#125;&quot; table-strategy-ref=&quot;orderTableShardingStrategy&quot; /&gt;</span><br><span class="line">                &lt;sharding:table-rule logic-table=&quot;apply_device&quot; actual-data-nodes=&quot;dataSource.apply_device_2017$&#123;1..54&#125;&quot; table-strategy-ref=&quot;applyDeviceTableShardingStrategy&quot; /&gt;</span><br><span class="line">            &lt;/sharding:table-rules&gt;</span><br><span class="line">            &lt;sharding:binding-table-rules&gt;</span><br><span class="line">                &lt;sharding:binding-table-rule logic-tables=&quot;apply_order,apply_device&quot;/&gt;</span><br><span class="line">            &lt;/sharding:binding-table-rules&gt;</span><br><span class="line">        &lt;/sharding:sharding-rule&gt;</span><br><span class="line">        &lt;sharding:props&gt;</span><br><span class="line">            &lt;prop key=&quot;sql.show&quot;&gt;true&lt;/prop&gt;</span><br><span class="line">        &lt;/sharding:props&gt;</span><br><span class="line">    &lt;/sharding:data-source&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis部分配置--&gt;</span><br><span class="line"> &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapper/*.xml&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 精确的查询，用于=，in等精确查询</span><br><span class="line"> */</span><br><span class="line">public final class PreciseTableShardingAlgorithm implements PreciseShardingAlgorithm&lt;Date&gt; &#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(PreciseTableShardingAlgorithm.class);</span><br><span class="line">    public String doSharding(final Collection&lt;String&gt; availableTargetNames, final PreciseShardingValue&lt;Date&gt; shardingValue) &#123;</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line">        String format = sdf.format(shardingValue.getValue());</span><br><span class="line">        Integer week = getWeek(shardingValue.getValue());</span><br><span class="line">        String tableName = format+week;</span><br><span class="line">        for (String each : availableTargetNames) &#123;</span><br><span class="line">            if (each.endsWith(tableName)) &#123;</span><br><span class="line">                logger.info(&quot;精确查询返回的表名：&quot;+each);</span><br><span class="line">                return each;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前日期的周数</span><br><span class="line">     * @param date</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Integer getWeek(Date date)&#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.setFirstDayOfWeek(Calendar.MONDAY);</span><br><span class="line">        instance.setTime(date);</span><br><span class="line">        int weekNum = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        //如果为12月份</span><br><span class="line">        if((instance.get(Calendar.MONTH)+1)==12)&#123;</span><br><span class="line">            instance.add(Calendar.WEEK_OF_YEAR,-1);</span><br><span class="line">            int weekNumBefore = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">            if(weekNum&lt;weekNumBefore)&#123;</span><br><span class="line">                return weekNumBefore+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return weekNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 范围查询分表</span><br><span class="line"> */</span><br><span class="line">public final class RangleTableShardingAlgorithm implements RangeShardingAlgorithm&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(RangleTableShardingAlgorithm.class);</span><br><span class="line"></span><br><span class="line">    public Collection&lt;String&gt; doSharding(Collection&lt;String&gt; collection, RangeShardingValue&lt;Date&gt; rangeShardingValue) &#123;</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(collection.size());</span><br><span class="line"></span><br><span class="line">        Range&lt;Date&gt; valueRange = rangeShardingValue.getValueRange();</span><br><span class="line">        Date beginDate = valueRange.lowerEndpoint();</span><br><span class="line">        Date endDate = valueRange.upperEndpoint();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdfYear = new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line">        Integer beginDateYear = Integer.valueOf(sdfYear.format(beginDate));</span><br><span class="line">        Integer endDateYear = Integer.valueOf(sdfYear.format(endDate));</span><br><span class="line">        Integer beginWeek = getWeek(beginDate);</span><br><span class="line">        Integer endWeek = getWeek(endDate);</span><br><span class="line">        //年份相等</span><br><span class="line">        if(beginDateYear.equals(endDateYear))&#123;</span><br><span class="line">            //比较月份</span><br><span class="line"></span><br><span class="line">            for (int i = beginWeek;i&lt;=endWeek;i++)&#123;</span><br><span class="line">                for (String tableName :collection)&#123;</span><br><span class="line">                    if(tableName.endsWith(beginDateYear+&quot;&quot;+i))&#123;</span><br><span class="line">                        result.add(tableName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //年份不等,遍历年份</span><br><span class="line">            for (int i = beginDateYear;i&lt;=endDateYear;i++)&#123;</span><br><span class="line">                //遍历月份</span><br><span class="line">                if(i==endDateYear)&#123;</span><br><span class="line">                    for (int j = beginWeek;j&lt;=endWeek;j++)&#123;</span><br><span class="line">                        for (String tableName :collection)&#123;</span><br><span class="line">                            if(tableName.endsWith(i+&quot;&quot;+j))&#123;</span><br><span class="line">                                result.add(tableName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    for (int j = beginWeek;j&lt;=12;j++)&#123;</span><br><span class="line">                        for (String tableName :collection)&#123;</span><br><span class="line">                            if(tableName.endsWith(i+&quot;&quot;+j))&#123;</span><br><span class="line">                                result.add(tableName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;范围查询返回的表名：&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前日期的周数</span><br><span class="line">     * @param date</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Integer getWeek(Date date)&#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.setFirstDayOfWeek(Calendar.MONDAY);</span><br><span class="line">        instance.setTime(date);</span><br><span class="line">        int weekNum = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        //如果为12月份</span><br><span class="line">        if((instance.get(Calendar.MONTH)+1)==12)&#123;</span><br><span class="line">            instance.add(Calendar.WEEK_OF_YEAR,-1);</span><br><span class="line">            int weekNumBefore = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">            if(weekNum&lt;weekNumBefore)&#123;</span><br><span class="line">                return weekNumBefore+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return weekNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的地方<br>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath*:application_local.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>不要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">&lt;property name=&quot;locations&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;classpath*:application_local.properties&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>不要将dataSource和shardingjdbc的规则放在一起，因为dataSource里面的${}和shardingjdbc里面的${}解析的时候用的不是一个工具。</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分表分库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于数据库水平拆分和垂直拆分</title>
      <link href="/2018/09/26/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E5%92%8C%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86/"/>
      <url>/2018/09/26/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E5%92%8C%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86/</url>
      <content type="html"><![CDATA[<p>###垂直拆分<br>垂直拆分 分为两种，一种是垂直分表，一种是垂直分库。</p><ul><li>垂直分表<br>垂直分表就是单表的列数比较多，并且有一些列存放的数据比较多，比如文章表的文章内容，或者一些列不需要经常查看的。这时可以使用垂直分表，将那些大容量的，不经常查看的列分到另一张表里面去，这样便可以增加查询的速度。</li><li>垂直分库</li></ul><p>###水平拆分</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分表分库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo集成gitalk的一些问题</title>
      <link href="/2018/09/10/hexo%E9%9B%86%E6%88%90gitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/10/hexo%E9%9B%86%E6%88%90gitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h4 id="新建OAuth-APP"><a href="#新建OAuth-APP" class="headerlink" title="新建OAuth APP"></a>新建OAuth APP</h4><ul><li>在github上Settings - Developer settings右边点击新建</li><li>Application name任意填写</li><li>Homepage URL和Authorization callback URL填写博客主页</li></ul><p>新建完成后生成Client ID和Client Secret</p><h4 id="设置gitalk"><a href="#设置gitalk" class="headerlink" title="设置gitalk"></a>设置gitalk</h4><ul><li>owner 填写github用户名</li><li>repo 填写博客的github仓库名称,例如xxx.github.io</li><li>client_id 填写Client ID</li><li>client_secret 填写Client Secret</li><li>admin 填写github用户名</li></ul><p>如果评论不了,可能是github邮箱未验证,登录验证即可.</p>]]></content>
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo d 无响应 hexo deploy 提交git失败</title>
      <link href="/2018/09/07/hexo-d-%E6%97%A0%E5%93%8D%E5%BA%94-hexo-d-%E6%8F%90%E4%BA%A4git%E5%A4%B1%E8%B4%A5/"/>
      <url>/2018/09/07/hexo-d-%E6%97%A0%E5%93%8D%E5%BA%94-hexo-d-%E6%8F%90%E4%BA%A4git%E5%A4%B1%E8%B4%A5/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">develop:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:xxx/xxx.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>在type: repo: branch:的后面必须有一个空格,不然就会发生这些错误</p>]]></content>
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/07/hello-world/"/>
      <url>/2018/09/07/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
