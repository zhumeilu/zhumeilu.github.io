<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>使用Intellij创建springboot项目Spring Initializr Error 403</title>
      <link href="/2018/09/26/%E4%BD%BF%E7%94%A8Intellij%E5%88%9B%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AESpring-Initializr-Error-403/"/>
      <url>/2018/09/26/%E4%BD%BF%E7%94%A8Intellij%E5%88%9B%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AESpring-Initializr-Error-403/</url>
      <content type="html"><![CDATA[<p>使用Spring Initializr创建项目时报错<br><img src="https://user-gold-cdn.xitu.io/2018/5/4/1632a39080f92029?w=1314&amp;h=568&amp;f=jpeg&amp;s=62843" alt=""></p><p>修改Intellij代理设置</p><p>在这里,我自己开启了ss,查看ss监听的地址和端口号,然后设置到Intellij中<br><img src="https://user-gold-cdn.xitu.io/2018/5/4/1632a3a79d6e426e?w=2204&amp;h=1352&amp;f=jpeg&amp;s=236072" alt=""></p><p>创建项目成功<br><img src="https://user-gold-cdn.xitu.io/2018/5/4/1632a3b9713ba8d1?w=1896&amp;h=1172&amp;f=jpeg&amp;s=134536" alt=""></p>]]></content>
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关闭tomcat报错Cannot allocate memory</title>
      <link href="/2018/09/26/%E5%85%B3%E9%97%ADtomcat%E6%8A%A5%E9%94%99Cannot-allocate-memory/"/>
      <url>/2018/09/26/%E5%85%B3%E9%97%ADtomcat%E6%8A%A5%E9%94%99Cannot-allocate-memory/</url>
      <content type="html"><![CDATA[<p>报错如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">90 #   CATALINA_PID    (Optional) Path of the file which should contains the pid</span><br><span class="line">Using CATALINA_BASE:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_HOME:   /usr/local/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /usr/local/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /root/software/jdk1.8.0_131</span><br><span class="line">Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x0000000080000000, 348913664, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12)</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 348913664 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># /usr/local/tomcat/hs_err_pid23927.log</span><br><span class="line">Kill failed: $CATALINA_PID not set</span><br></pre></td></tr></table></figure></p><p>主要是系统内存不够,无法分配内存了</p><p>解决方案:<br>修改./bin/catalina.sh中的内存分配<br>将最小内存修改到系统剩余内存以内</p><p><code>JAVA_OPTS=&quot; -server -Xms256M -Xmx2048M</code></p>]]></content>
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树java实现</title>
      <link href="/2018/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91java%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91java%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>二叉树节点的定义:</p><pre><code>public class BinaryNode {    Object element;        //节点存储的值    BinaryNode left;    //左孩子    BinaryNode right;    //右孩子}</code></pre><p>定义二叉查找树:</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记七 高可用注册中心</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      <content type="html"><![CDATA[<p>###介绍<br>Eureka Server除了单点运行之外，还可以通过运行多个实例，并进行互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署。</p><p>创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer2和peer3</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=peer1server.port=1111#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/,http://peer3:1113/eureka/management.security.enabled=false</code></pre><p>创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer1和peer3</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=peer2server.port=1112#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://peer3:1113/eureka/,http://peer1:1111/eureka/management.security.enabled=false</code></pre><p>创建application-peer3.properties，作为peer3服务中心的配置，并将serviceUrl指向peer1和peer2</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=peer3server.port=1113#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/,http://peer1:1111/eureka/management.security.enabled=false</code></pre><p>将其打成jar包<br>执行<code>java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer1</code><br><code>java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer2</code><br><code>java -jar eureka-server-1.0.0.jar --spring.profiles.active=peer3</code></p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记八 消息总线</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/</url>
      <content type="html"><![CDATA[<p>###springboot整合RabbitMQ</p><ul><li>安装rabbitmq</li><li>进入cmd进入D:\RabbitMQ Server\rabbitmq_server-3.6.10\sbin</li><li>执行rabbitmq-plugins enable rabbitmq_management</li><li>打开浏览器并访问：<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></li><li>默认账户密码都为guest</li></ul><p>创建项目<br>依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=rabbitmq-demo</span><br><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=123456</span><br></pre></td></tr></table></figure><p>消息生产者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Sender &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context = &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息消费者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;hello&quot;)</span><br><span class="line">public class Receiver &#123;</span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>rabbit配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Application<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class HelloApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = Application.class)</span><br><span class="line">public class ApplicationTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Sender sender;</span><br><span class="line">    @Test</span><br><span class="line">    public void hello() throws Exception &#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###springcloud整合RabbitMQ使用消息总线更新配置文件</p><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置文件添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=123456</span><br></pre></td></tr></table></figure><p>发送post请求到localhost:2001/bus/refresh便可以刷新所有服务的配置</p><p>####原理分析<br>我们通过使用Spring Cloud Bus与Spring Cloud Config的整合，并以RabbitMQ作为消息代理，实现了应用配置的动态更新。<br><img src="http://blog.didispace.com/assets/5-6.png" alt="abc"></p><p>整个方案的架构如上图所示，其中包含了Git仓库、Config Server、以及微服务“Service A”的三个实例，这三个实例中都引入了Spring Cloud Bus，所以他们都连接到了RabbitMQ的消息总线上。</p><p>当我们将系统启动起来之后，“Service A”的三个实例会请求Config Server以获取配置信息，Config Server根据应用配置的规则从Git仓库中获取配置信息并返回。</p><p>此时，若我们需要修改“Service A”的属性。首先，通过Git管理工具去仓库中修改对应的属性值，但是这个修改并不会触发“Service A”实例的属性更新。我们向“Service A”的实例3发送POST请求，访问/bus/refresh接口。此时，“Service A”的实例3就会将刷新请求发送到消息总线中，该消息事件会被“Service A”的实例1和实例2从总线中获取到，并重新从Config Server中获取他们的配置信息，从而实现配置信息的动态更新。</p><p>而从Git仓库中配置的修改到发起/bus/refresh的POST请求这一步可以通过Git仓库的Web Hook来自动触发。由于所有连接到消息总线上的应用都会接受到更新请求，所以在Web Hook中就不需要维护所有节点内容来进行更新，从而解决了通过Web Hook来逐个进行刷新的问题。</p><p>####指定刷新范围<br>上面的例子中，我们通过向服务实例请求Spring Cloud Bus的/bus/refresh接口，从而触发总线上其他服务实例的/refresh。但是有些特殊场景下（比如：灰度发布），我们希望可以刷新微服务中某个具体实例的配置。</p><p>Spring Cloud Bus对这种场景也有很好的支持：/bus/refresh接口还提供了destination参数，用来定位具体要刷新的应用程序。比如，我们可以请求/bus/refresh?destination=customers:9000，此时总线上的各应用实例会根据destination属性的值来判断是否为自己的实例名，若符合才进行配置刷新，若不符合就忽略该消息。</p><p>destination参数除了可以定位具体的实例之外，还可以用来定位具体的服务。定位服务的原理是通过使用Spring的PathMatecher（路径匹配）来实现，比如：/bus/refresh?destination=customers:**，该请求会触发customers服务的所有实例进行刷新。</p><p>####架构优化</p><p>既然Spring Cloud Bus的/bus/refresh接口提供了针对服务和实例进行配置更新的参数，那么我们的架构也相应的可以做出一些调整。在之前的架构中，服务的配置更新需要通过向具体服务中的某个实例发送请求，再触发对整个服务集群的配置更新。虽然能实现功能，但是这样的结果是，我们指定的应用实例就会不同于集群中的其他应用实例，这样会增加集群内部的复杂度，不利于将来的运维工作，比如：我们需要对服务实例进行迁移，那么我们不得不修改Web Hook中的配置等。所以我们要尽可能的让服务集群中的各个节点是对等的。</p><p>因此，我们将之前的架构做了一些调整，如下图所示：</p><p><img src="http://blog.didispace.com/assets/5-7.png" alt=""></p><p>我们主要做了这些改动：</p><ul><li>在Config Server中也引入Spring Cloud Bus，将配置服务端也加入到消息总线中来。</li><li>/bus/refresh请求不在发送到具体服务实例上，而是发送给Config Server，并通过destination参数来指定需要更新配置的服务或实例。</li></ul><p>通过上面的改动，我们的服务实例就不需要再承担触发配置更新的职责。同时，对于Git的触发等配置都只需要针对Config Server即可，从而简化了集群上的一些维护工作。</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ribbon</title>
      <link href="/2018/09/26/Ribbon/"/>
      <url>/2018/09/26/Ribbon/</url>
      <content type="html"><![CDATA[<p>在springcloud中，引入Ribbon来作为客户端时，负载均衡使用的是被<code>@LoadBalanced</code>修饰的<code>RestTemplate</code>对象。</p><p>####RestTemplate详细的用法</p><ul><li><p>GET请求</p><p>第一种方式<br>返回ResponseEntity，该对象是Spring对HTTP请求响应的封装，其中主要存储了HTTP的几个重要元素，HttpStatus代表了错误码如404,500等。以及HttpHeaders代表了请求头，body代表了接收到的对象，其类型是根据第二个参数决定的。第一个url为请求地址，可以使用{1}占位符，而参数的值在该方法的最后的可变参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(&quot;http://eureka-client/hello&quot;,String.class);</span><br><span class="line">String body = forEntity.getBody();</span><br><span class="line">HttpHeaders headers = forEntity.getHeaders();</span><br><span class="line">HttpStatus statusCode = forEntity.getStatusCode();</span><br></pre></td></tr></table></figure></li></ul><p>三个重载方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getForEntity(String url,Class responseType,Object... urlVariables);</span><br><span class="line">getForEntity(String url,Class responseType,Map urlVariables);</span><br><span class="line">getForEntity(URI url,Class responseType);</span><br></pre></td></tr></table></figure></p><p>第二种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String forObject = restTemplate.getForObject(&quot;http://eureka-client/hello&quot;, String.class);</span><br></pre></td></tr></table></figure></p><p>第二种方式与第一种方式唯一的不同就是getForObject的返回值类型直接就是参数列表的第二个参数指定的类型，所以这种方式没法获取错误码和请求头等信息。</p><p>RestTemplate本来是Spring提供的发送REST请求的工具类，但是当其被@LoadBalanced注解修饰后，通过其发送REST请求，会被LoadBalanceInterceptor类的inteceptor拦截，然后进行一些负载均衡和请求地址的转换。</p><p>####负载均衡策略<br>通过继承AbstractLoadBalancerRule抽象类来具体实现负载均衡策略。<br>RandomRule<br>通过随机服务实例的数量来产生一个随机数，通过索引获取该服务实例</p><p>RoundRobinRule<br>按照线性轮询的方式依次选择每个服务实例的功能<br>RetryRule<br>该策略实现了一个具备重试机制的实例选择功能。其内部还定义了一个IRule对象，默认使用RoundRobinRule实例。在choose方法中则实现了对内部定义的策略进行反复尝试的策略，若期间能够选择到具体的服务实例就返回，若选择不到就根据设置的尝试结束时间为阀值（maxRetryMillis参数定义的值+choose方法开始执行是的时间戳），当超过该值后就返回null<br>WeightedResponseTimeRule<br>该策略是对RoundRobinRule的扩展，增加了根据实例的运行情况来计数权重，并根据权重来挑选实例。该策略实例化的时候在内部创建了一个定时任务，每过30s便去统计一下各个实例的权重。<br>ClientConfigEnableRoundRobinRule<br>该策略较为特殊，一般不直接使用它。该策略内部定义了一个RoundRobinRule策略，choose函数的实现也是使用了RoundRobinRule的线下轮询机制。一般使用方法：继承该策略，默认的choose方法实现了线性轮询机制，在子类中做一些高级策略时通常可能会存在一些无法实施的情况，那么就可以用父类的实现作为备选。<br>BestAvailableRule<br>该策略继承ClientConfigEnableRoundRobinRule，在实现中它注入了负载均衡器的统计对象LoadBalancerStats，同时在具体的choose算法中利用LoadBalancerStats保存的实例统计信息来满足要求的实例。它通过遍历负载均衡器中维护的所有服务实例，会过滤掉故障的实例，并找出并发请求数最少的一个，所以该策略的特性是可选出最空闲的实例。<br>PredicateBasedRule<br>抽象策略，继承了ClientConfigEnableRoundRobinRule，基于Predicate实现的策略，Predicate是Google Guava Collection工具对集合进行过滤的条件接口，策略：先过滤清单，在轮询选择</p><p>AvailableFilteringRule<br>继承自PredicationBasedRule</p><p>ZoneAvoidanceRule<br>继承自PredicationBasedRule</p><p>####重试<br>spring cloud eureka比较注重可用性，所以在极端情况下，它宁愿接收故障实例也不会丢掉“健康”实例，比如当服务注册中心的网络发生故障断开时，由于所有的服务实例无法持续维持心跳，一般的服务治理会将所有的服务实例剔除，但是eureka则会因为超过85%的实例丢失心跳而触发保护机制，注册中心将会保留此时的所有节点，以实现服务间依然可以进行互相调用的场景，即使其中有部分故障节点，但这样做可以继续保障大多数的服务正常消费。<br>由于spring cloud eureka咋可用性与一致性上的取舍，所以我们在实现服务调用的时候通常会加入一些重试机制。spring cloud 整合了spring retry来增强RestTemplate的重试能力，只需通过简单的配置，原来那些通过RestTemplate实现的服务访问就会自动根据配置来实现重试策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.loadbalancer.retry.enabled=true</span><br><span class="line">#开启重试机制</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000</span><br><span class="line">#断路器的超时时间需要大于Ribbon的超时时间，不然不会触发重试</span><br><span class="line">eureka-consumer.ribbon.ConnectTimeout=250</span><br><span class="line">#请求连接的超时时间</span><br><span class="line">eureka-consumer.ribbon.ReadTimeout=1000</span><br><span class="line">#请求处理的超时时间</span><br><span class="line">eureka-consumer.ribbon.OkToRetryOnAllOperations=true</span><br><span class="line">#对所有操作请求都进行重试</span><br><span class="line">eureka-consumer.ribbon.MaxAutoRetriesNextServer=2</span><br><span class="line">#切换实例的重试次数</span><br><span class="line">eureka-consumer.ribbon.MaxAutoRetries=1</span><br><span class="line">#对当前实例的重试次数</span><br></pre></td></tr></table></figure></p><p>当访问到故障请求的时候，它会在尝试访问一次当前实例（次数由MaxAutoRetries配置），如果不行，就换一个实例进行访问，如果还是不行，在换一次实例访问（更换次数由MaxAutoRetriesNextServer配置），如果依然不行，在返回失败信息。</p>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>游戏服务器分析</title>
      <link href="/2018/09/26/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/26/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>ServerServiceManager服务启动管理器，单例，包含一个Map<string serviceid,iservice="">  方法：注册服务，获取服务，移除服务</string></p><p>GlobalManager  各种全局的业务管理器、公共服务实例的持有者，负责各种管理器的初始化和实例的获取</p><p>LocalNetService  本地网络服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">GameServer server = new GameServer();</span><br><span class="line"></span><br><span class="line">       super(ServerServiceManager.SERVICE_ID_ROOT);</span><br><span class="line">       this.globalManager = new GlobalManager();</span><br><span class="line">       this.localNetService = new LocalNetService();</span><br><span class="line"></span><br><span class="line">server.startServer();</span><br><span class="line">    输出日志：服务器启动中</span><br><span class="line">    init(configFile);</span><br><span class="line">        initSpring();   初始化spring容器</span><br><span class="line">        globalManager.init(configFile);</span><br><span class="line">            //从spring中获取localSpringBeanManager的实例，然后设置到LocalMananger里面的localSpringBeanManager成员变量中。localSpringServiceManager，localSpringServicerAfterManager</span><br><span class="line">            initLocalManger();</span><br><span class="line">            //初始化本地服务// //初始化game-excutor更新服务</span><br><span class="line">            initLocalService();</span><br><span class="line"></span><br><span class="line">           //初始化消息处理器</span><br><span class="line">           //根据使用的协议的不同，初始化tcp和udp处理队列    gameTcpMessageProcessor，GameUdpMessageOrderProcessor，并将其添加到LocalMananger中</span><br><span class="line">           initNetMessageProcessor();</span><br><span class="line">           //扩展使用（没有内容）</span><br><span class="line">           initGameManager();</span><br><span class="line">    start();</span><br><span class="line">          //根据更新器执行类型启动更新服务updateService.start();</span><br><span class="line">          globalManager.start();</span><br><span class="line">          //首先初始化处理器initChannelInitializer();根据 GameServerConfig，创建GameNettyTcpServerService，GameNettyUdpServerService，GameNettyRPCService</span><br><span class="line">          localNetService.startup();</span><br><span class="line">          //创建服务器启动结束服务 并调用启动startup方法，并且添加到了LocalManager中</span><br><span class="line">          LocalMananger.getInstance().create(GamerServerStartFinishedService.class, GamerServerStartFinishedService.class);</span><br><span class="line">           //注册停服监听器，用于执行资源的销毁等停服时的处理工作</span><br><span class="line">          addShutdownHook();</span><br><span class="line">          //游戏服务器运行时数据，打开服务</span><br><span class="line">         GameServerRuntime.setOpenOn();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    输出日志：服务器启动成功,正在运行</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>redis简单的操作</title>
      <link href="/2018/09/26/redis%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/09/26/redis%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>常用数据结构<br>redis简单操作</p><pre><code>public class Test1 {    @Test    public void test() {        Jedis jedis = new Jedis(&quot;192.168.1.96&quot;);        String zml = jedis.get(&quot;zml&quot;);        System.out.println(zml);        if(zml==null){            jedis.set(&quot;zml&quot;, &quot;zhumeilu&quot;);        }        System.out.println(jedis.get(&quot;zml&quot;));    }}</code></pre><p>redis池化</p><p>配置文件</p><pre><code>#最大分配的对象数  redis.pool.maxActive=1024#最大能够保持idel状态的对象数  redis.pool.maxIdle=200#当池内没有返回对象时，最大等待时间  redis.pool.maxWait=1000#当调用borrow Object方法时，是否进行有效性检查  redis.pool.testOnBorrow=true#当调用return Object方法时，是否进行有效性检查  redis.pool.testOnReturn=true#IP  redis.ip=192.168.1.96#Port  redis.port=6379</code></pre><p>创建一个redis池工具类</p><pre><code>public class RedisClient {    private static JedisPool pool;    static{        ResourceBundle bundle = ResourceBundle.getBundle(&quot;redis&quot;);        if(bundle==null){            throw new RuntimeException(&quot;reids.propertis为空&quot;);        }        System.out.println(bundle);        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxActive(Integer.valueOf(bundle.getString(&quot;redis.pool.maxActive&quot;)));        config.setMaxIdle(Integer.valueOf(bundle.getString(&quot;redis.pool.maxIdle&quot;)));        config.setMaxWait(Integer.valueOf(bundle.getString(&quot;redis.pool.maxWait&quot;)));        config.setTestOnBorrow(Boolean.valueOf(bundle.getString(&quot;redis.pool.testOnBorrow&quot;)));        config.setTestOnBorrow(Boolean.valueOf(bundle.getString(&quot;redis.pool.testOnReturn&quot;)));        pool = new JedisPool(config, bundle.getString(&quot;redis.ip&quot;));    }    public static JedisPool getPool() {        return pool;    }}</code></pre><p>通过JedisPool获取jedis实例</p><pre><code>public class TestPool {    @Test    public void test() {        JedisPool pool = RedisClient.getPool();        Jedis jedis = pool.getResource();        System.out.println(jedis);        String zml = jedis.get(&quot;zml&quot;);        System.out.println(zml);        pool.returnResource(jedis);    }}</code></pre>]]></content>
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>shardingjdbc+spring使用路由数据源支持DISTINCT</title>
      <link href="/2018/09/26/shardingjdbc-spring%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90%E6%94%AF%E6%8C%81DISTINCT/"/>
      <url>/2018/09/26/shardingjdbc-spring%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90%E6%94%AF%E6%8C%81DISTINCT/</url>
      <content type="html"><![CDATA[<p>大概思路就是使用AbstractRoutingDataSource来动态切换数据源，当需要使用DISTINCT的时候，切换成功原生数据源，来进行查询。在这里还需要自己根据自定义的规则查询表名。</p><p>原生数据源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;nativeDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span><br><span class="line">init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;db.master.url&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;db.master.user&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;db.master.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>sharingjdbc数据源，内部还是引用了原生数据源的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;sharding:data-source id=&quot;shardingDataSource&quot;&gt;</span><br><span class="line">    &lt;sharding:sharding-rule data-source-names=&quot;nativeDataSource&quot;&gt;</span><br><span class="line">        &lt;sharding:table-rules&gt;</span><br><span class="line">            &lt;sharding:table-rule logic-table=&quot;apply_order&quot; actual-data-nodes=&quot;nativeDataSource.apply_order_$&#123;[2017,2018]&#125;$&#123;1..54&#125;&quot; table-strategy-ref=&quot;orderTableShardingStrategy&quot; /&gt;</span><br><span class="line">            &lt;sharding:table-rule logic-table=&quot;apply_device&quot; actual-data-nodes=&quot;nativeDataSource.apply_device_$&#123;[2017,2018]&#125;$&#123;1..54&#125;&quot; table-strategy-ref=&quot;applyDeviceTableShardingStrategy&quot; /&gt;</span><br><span class="line">            &lt;sharding:table-rule logic-table=&quot;awake_request_record&quot; actual-data-nodes=&quot;nativeDataSource.awake_request_record_$&#123;[2017,2018]&#125;$&#123;1..12&#125;&quot; table-strategy-ref=&quot;awakeRequestRecordTableShardingStrategy&quot; /&gt;</span><br><span class="line">        &lt;/sharding:table-rules&gt;</span><br><span class="line">        &lt;sharding:binding-table-rules&gt;</span><br><span class="line">            &lt;sharding:binding-table-rule logic-tables=&quot;apply_order,apply_device,awake_request_record&quot;/&gt;</span><br><span class="line">        &lt;/sharding:binding-table-rules&gt;</span><br><span class="line">    &lt;/sharding:sharding-rule&gt;</span><br><span class="line">    &lt;sharding:props&gt;</span><br><span class="line">        &lt;prop key=&quot;sql.show&quot;&gt;true&lt;/prop&gt;</span><br><span class="line">    &lt;/sharding:props&gt;</span><br><span class="line">&lt;/sharding:data-source&gt;</span><br></pre></td></tr></table></figure><p>路由数据源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;dataSource&quot; class=&quot;com.dsp.common.datasource.DynamicDataSource&quot; &gt;</span><br><span class="line">&lt;!-- 已配置的数据源 --&gt;</span><br><span class="line">&lt;property name=&quot;targetDataSources&quot;&gt;</span><br><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry key=&quot;shardingDataSource&quot; value-ref=&quot;shardingDataSource&quot;/&gt;</span><br><span class="line">&lt;entry key=&quot;nativeDataSource&quot; value-ref=&quot;nativeDataSource&quot;/&gt;</span><br><span class="line">&lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 默认的数据源 --&gt;</span><br><span class="line">&lt;property name=&quot;defaultTargetDataSource&quot; ref=&quot;shardingDataSource&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>接着在mybatis引用数据源的地方使用这个路由数据源</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shardingjdbc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springcloud微服务实战 学习笔记一 服务注册中心</title>
      <link href="/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2018/09/26/springcloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      <content type="html"><![CDATA[<h3 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h3><ul><li><p>添加依赖</p><pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;            &lt;version&gt;Dalston.SR1&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li><li><p>配置文件</p><pre><code>spring.application.name=eureka-servereureka.instance.hostname=localhostserver.port=1111#禁用自身注册为客户端eureka.client.register-with-eureka=falseeureka.client.fetch-registry=false</code></pre></li><li><p>Application.java</p><pre><code>@EnableEurekaServer //启动一个服务注册中心提供给其他应用进行对话@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }}</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用谷歌云服务开启8080等其他的端口</title>
      <link href="/2018/09/26/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF8080%E7%AD%89%E5%85%B6%E4%BB%96%E7%9A%84%E7%AB%AF%E5%8F%A3/"/>
      <url>/2018/09/26/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF8080%E7%AD%89%E5%85%B6%E4%BB%96%E7%9A%84%E7%AB%AF%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>最近使用朋友的谷歌云服务器，发现无法开启8080等一些端口，查了很多资料，也改了防火墙之类的都没有效果，最后翻墙google了一下，找到了解决方案。</p><p>登录谷歌云服务器</p><ul><li>查询所有防火墙规则<pre><code>gcloud compute firewall-rules list</code></pre></li><li>创建一个名为allow-ssr，端口号为1099的规则<pre><code>gcloud compute firewall-rules create allow-ssr --allow tcp:1099</code></pre></li><li>删除一个名为allow-ssr的防火墙规则<pre><code>gcloud compute firewall-rules delete allow-ssr</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>nginx配置文件</title>
      <link href="/2018/09/26/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/09/26/nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>nginx的启动：nginx<br>重启：nginx -s reload<br>快读关闭： nginx -s stop<br>安全关闭：nginx -s quit</p><p>nginx配置文件：</p><pre><code>server {    #监听80端口    listen       80;     #服务器的名称    server_name  localhost;     #访问日志   日志格式main需要在前面定义    access_log  logs/host.access.log  main;     #location / 代表匹配根路径下的所有资源   location后面跟一个正则表达式，用来匹配请求的资源。    location / {             #资源文件加载的根路径，一些静态资源文件，如静态的html，js，css，图片等。        root   html;         #首页默认页面        index  index.html index.htm;       }    #以jsp结尾的资源文件，proxy_pass   http://127.0.0.1代表转发给http://127.0.0.1     location ~ .*.jsp$ {        proxy_pass   http://127.0.0.1;    }    #禁止访问WEB-INF里面的文件    location ~ ^/WEB-INF/ {        deny  all;    }    # 错误404页面    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #服务器错误500页面    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   html;    }}      </code></pre><p>为上面这些配置文件单独命名，比如<a href="http://www.zhumeilu.me.conf" target="_blank" rel="noopener">www.zhumeilu.me.conf</a> 保存在nginx.conf同级目录或者自己创建一个子目录，然后在nginx.conf的http里面添加一行，也就是代替了原来的server{}，这样做的好处可以分开管理多个服务器</p><pre><code>include www.zhumeilu.me.conf</code></pre><p>nginx的负载均衡：<br>分配策略：</p><ul><li>轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</li><li>weight<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</li><li><p>ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  </p></li><li><p>fair<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。 </p></li><li><p>url_hash<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。<br>修改配置文件：</p><pre><code>#定义负载均衡设备的 ip及设备状态 upstream myServer {    server localhost:8080;  server localhost:8081;  server localhost:8082;  server localhost:8083;  ip_hash;}server { location ~ .*.jsp$ {      proxy_pass   http://myServer;  }}</code></pre></li></ul>]]></content>
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql中文乱码</title>
      <link href="/2018/09/26/mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/09/26/mysql%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<ul><li>最近项目中遇到了中文乱码，一开始以为是编码过滤器没有配置好路径，接着debug后发现前天传到后天的数据没有乱码。</li><li>那么就是数据存到数据库的过程中出现了问题，我清楚的记得我创建数据库的时候指定了utf8的编码，所以应该不是这个问题。</li><li><p>那么就是连接数据库的时候出的问题了，接着百度了一下，在连接的url里面加上了两个参数useUnicode=true&amp;characterEncoding=utf-8，然后问题解决。</p><p>  //连接地址：<br>  jdbc:mysql://127.0.0.1:3306/abc?useUnicode=true&amp;characterEncoding=utf-8</p></li></ul>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mongodb学习笔记一</title>
      <link href="/2018/09/26/mongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/09/26/mongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>首先引入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mongodb&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">MongoClient mc = null;</span><br><span class="line">MongoDatabase database = null;</span><br><span class="line">MongoCollection&lt;Document&gt; collection = null;</span><br><span class="line">@Before</span><br><span class="line">public void before()&#123;</span><br><span class="line">    //建立一个连接</span><br><span class="line">    mc = new MongoClient(&quot;localhost&quot;,27017 );</span><br><span class="line">    //获取一个数据库</span><br><span class="line">    database = mc.getDatabase(&quot;mydb&quot;);</span><br><span class="line">    //获取一个集合</span><br><span class="line">    collection = database.getCollection(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void insert()&#123;</span><br><span class="line">    //创建一个文档</span><br><span class="line">    Document doc = new Document(&quot;name&quot;, &quot;MongoDB&quot;)</span><br><span class="line">            .append(&quot;type&quot;, &quot;database&quot;)</span><br><span class="line">            .append(&quot;count&quot;, 1)</span><br><span class="line">            .append(&quot;versions&quot;, Arrays.asList(&quot;v3.2&quot;, &quot;v3.0&quot;, &quot;v2.6&quot;))</span><br><span class="line">            .append(&quot;info&quot;, new Document(&quot;x&quot;, 203).append(&quot;y&quot;, 102));</span><br><span class="line">    //插入一个文档</span><br><span class="line">    collection.insertOne(doc);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void insertMany()&#123;</span><br><span class="line">    //插入多个文档</span><br><span class="line">    List&lt;Document&gt; documents = new ArrayList&lt;Document&gt;();</span><br><span class="line">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        documents.add(new Document(&quot;i&quot;, i));</span><br><span class="line">    &#125;</span><br><span class="line">    collection.insertMany(documents);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void count()&#123;</span><br><span class="line">    //集合长度</span><br><span class="line">    System.out.println(&quot;集合长度：&quot;+collection.count());</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public  void firstQuery()&#123;</span><br><span class="line">    //获取集合第一个文档</span><br><span class="line">    Document myDoc = collection.find().first();</span><br><span class="line">    System.out.println(myDoc.toJson());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void allQuery()&#123;</span><br><span class="line">    //遍历集合，获取每个文档</span><br><span class="line">    MongoCursor&lt;Document&gt; cursor = collection.find().iterator();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (cursor.hasNext()) &#123;</span><br><span class="line">            System.out.println(cursor.next().toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void allQuery2()&#123;</span><br><span class="line">    //遍历集合，获取每个文档</span><br><span class="line">    //官方不推荐这种用法</span><br><span class="line">    for (Document cur : collection.find()) &#123;</span><br><span class="line">        System.out.println(cur.toJson());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void allQuery3()&#123;</span><br><span class="line">    //遍历集合，获取每个文档,分页</span><br><span class="line">    //skip()方法默认参数为 0 </span><br><span class="line">    MongoCursor&lt;Document&gt; cursor = collection.find().skip(10).limit(5).iterator();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (cursor.hasNext()) &#123;</span><br><span class="line">            System.out.println(cursor.next().toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void eq()&#123;</span><br><span class="line"></span><br><span class="line">    //查询i=100的文档</span><br><span class="line">    Document myDoc = collection.find(Filters.eq(&quot;i&quot;, 100)).first();</span><br><span class="line">    System.out.println(myDoc.toJson());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void gt()&#123;</span><br><span class="line">    //查询i&gt;50</span><br><span class="line">    Block&lt;Document&gt; printBlock = new Block&lt;Document&gt;() &#123;</span><br><span class="line">        public void apply(final Document document) &#123;</span><br><span class="line">            System.out.println(document.toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    collection.find(Filters.gt(&quot;i&quot;, 50)).forEach(printBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void between()&#123;</span><br><span class="line">    //查询i&gt;=50 and i&lt;=100</span><br><span class="line">    Block&lt;Document&gt; printBlock = new Block&lt;Document&gt;() &#123;</span><br><span class="line">        public void apply(final Document document) &#123;</span><br><span class="line">            System.out.println(document.toJson());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    collection.find(Filters.and(gte(&quot;i&quot;, 50), Filters.lte(&quot;i&quot;, 100))).forEach(printBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void updateOne()&#123;</span><br><span class="line"></span><br><span class="line">    collection.updateOne(Filters.eq(&quot;i&quot;, 10), new Document(&quot;$set&quot;, new Document(&quot;i&quot;, 110)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void updateMany()&#123;</span><br><span class="line">    UpdateResult updateResult = collection.updateMany(Filters.lt(&quot;i&quot;, 100), Updates.inc(&quot;i&quot;, 100));</span><br><span class="line">    System.out.println(updateResult.getModifiedCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void deleteOne()&#123;</span><br><span class="line">    collection.deleteOne(Filters.eq(&quot;i&quot;, 110));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void deleteBetween()&#123;</span><br><span class="line">    DeleteResult deleteResult = collection.deleteMany(Filters.gte(&quot;i&quot;, 100));</span><br><span class="line">    System.out.println(deleteResult.getDeletedCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void addIndex()&#123;</span><br><span class="line">    collection.createIndex(new Document(&quot;i&quot;, 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac下安装配置nginx</title>
      <link href="/2018/09/26/mac%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnginx/"/>
      <url>/2018/09/26/mac%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnginx/</url>
      <content type="html"><![CDATA[<p>因为mac自带apache2的原因，所以80端口被占用，而安装的nginx默认使用8080端口。<br>因为之前安装过了homebrew，所以使用homebrew安装nginx，这样也比较方便。<br>直接在终端运行brew install nginx就可以了。默认安装完的nginx路径为/usr/local/etc/nginx，页面的加载地址为/usr/local/var/www<br>在终端运行nginx，然后nginx就启动了。<br>接着在浏览器中输入localhost:8080就可以看到nginx已经运行。</p>]]></content>
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shardingjdbc分表分库，主从分离</title>
      <link href="/2018/09/26/shardingjdbc%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/"/>
      <url>/2018/09/26/shardingjdbc%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB/</url>
      <content type="html"><![CDATA[<p>使用shardingjdbc需要修改mybatis的数据源。原来是mybatis直接引用dataSource，现在需要将dataSource注入到shardingjdbc，然后在将shardingjdbc的shardingDataSource注入给mybatis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--数据源--&gt;</span><br><span class="line">&lt;bean name=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span><br><span class="line">init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;db.master.url&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;db.master.user&#125;&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;db.master.password&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>对apply_orde，apply_device这两张表进行分表，按createtime进行分表，每周分一张表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--shardingjdbc的规则--&gt;</span><br><span class="line">&lt;sharding:standard-strategy id=&quot;orderTableShardingStrategy&quot; sharding-column=&quot;createtime&quot; range-algorithm-class=&quot;com.dsp.common.algorithm.RangleTableShardingAlgorithm&quot; precise-algorithm-class=&quot;com.dsp.common.algorithm.PreciseTableShardingAlgorithm&quot;/&gt;</span><br><span class="line">    &lt;sharding:standard-strategy id=&quot;applyDeviceTableShardingStrategy&quot; sharding-column=&quot;createtime&quot; range-algorithm-class=&quot;com.dsp.common.algorithm.RangleTableShardingAlgorithm&quot; precise-algorithm-class=&quot;com.dsp.common.algorithm.PreciseTableShardingAlgorithm&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sharding:data-source id=&quot;shardingDataSource&quot;&gt;</span><br><span class="line">        &lt;sharding:sharding-rule data-source-names=&quot;dataSource&quot;&gt;</span><br><span class="line">            &lt;sharding:table-rules&gt;</span><br><span class="line">                &lt;sharding:table-rule logic-table=&quot;apply_order&quot; actual-data-nodes=&quot;dataSource.apply_order_2017$&#123;1..54&#125;&quot; table-strategy-ref=&quot;orderTableShardingStrategy&quot; /&gt;</span><br><span class="line">                &lt;sharding:table-rule logic-table=&quot;apply_device&quot; actual-data-nodes=&quot;dataSource.apply_device_2017$&#123;1..54&#125;&quot; table-strategy-ref=&quot;applyDeviceTableShardingStrategy&quot; /&gt;</span><br><span class="line">            &lt;/sharding:table-rules&gt;</span><br><span class="line">            &lt;sharding:binding-table-rules&gt;</span><br><span class="line">                &lt;sharding:binding-table-rule logic-tables=&quot;apply_order,apply_device&quot;/&gt;</span><br><span class="line">            &lt;/sharding:binding-table-rules&gt;</span><br><span class="line">        &lt;/sharding:sharding-rule&gt;</span><br><span class="line">        &lt;sharding:props&gt;</span><br><span class="line">            &lt;prop key=&quot;sql.show&quot;&gt;true&lt;/prop&gt;</span><br><span class="line">        &lt;/sharding:props&gt;</span><br><span class="line">    &lt;/sharding:data-source&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis部分配置--&gt;</span><br><span class="line"> &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapper/*.xml&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 精确的查询，用于=，in等精确查询</span><br><span class="line"> */</span><br><span class="line">public final class PreciseTableShardingAlgorithm implements PreciseShardingAlgorithm&lt;Date&gt; &#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(PreciseTableShardingAlgorithm.class);</span><br><span class="line">    public String doSharding(final Collection&lt;String&gt; availableTargetNames, final PreciseShardingValue&lt;Date&gt; shardingValue) &#123;</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line">        String format = sdf.format(shardingValue.getValue());</span><br><span class="line">        Integer week = getWeek(shardingValue.getValue());</span><br><span class="line">        String tableName = format+week;</span><br><span class="line">        for (String each : availableTargetNames) &#123;</span><br><span class="line">            if (each.endsWith(tableName)) &#123;</span><br><span class="line">                logger.info(&quot;精确查询返回的表名：&quot;+each);</span><br><span class="line">                return each;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前日期的周数</span><br><span class="line">     * @param date</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Integer getWeek(Date date)&#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.setFirstDayOfWeek(Calendar.MONDAY);</span><br><span class="line">        instance.setTime(date);</span><br><span class="line">        int weekNum = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        //如果为12月份</span><br><span class="line">        if((instance.get(Calendar.MONTH)+1)==12)&#123;</span><br><span class="line">            instance.add(Calendar.WEEK_OF_YEAR,-1);</span><br><span class="line">            int weekNumBefore = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">            if(weekNum&lt;weekNumBefore)&#123;</span><br><span class="line">                return weekNumBefore+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return weekNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 范围查询分表</span><br><span class="line"> */</span><br><span class="line">public final class RangleTableShardingAlgorithm implements RangeShardingAlgorithm&lt;Date&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(RangleTableShardingAlgorithm.class);</span><br><span class="line"></span><br><span class="line">    public Collection&lt;String&gt; doSharding(Collection&lt;String&gt; collection, RangeShardingValue&lt;Date&gt; rangeShardingValue) &#123;</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; result = new LinkedHashSet&lt;String&gt;(collection.size());</span><br><span class="line"></span><br><span class="line">        Range&lt;Date&gt; valueRange = rangeShardingValue.getValueRange();</span><br><span class="line">        Date beginDate = valueRange.lowerEndpoint();</span><br><span class="line">        Date endDate = valueRange.upperEndpoint();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdfYear = new SimpleDateFormat(&quot;yyyy&quot;);</span><br><span class="line">        Integer beginDateYear = Integer.valueOf(sdfYear.format(beginDate));</span><br><span class="line">        Integer endDateYear = Integer.valueOf(sdfYear.format(endDate));</span><br><span class="line">        Integer beginWeek = getWeek(beginDate);</span><br><span class="line">        Integer endWeek = getWeek(endDate);</span><br><span class="line">        //年份相等</span><br><span class="line">        if(beginDateYear.equals(endDateYear))&#123;</span><br><span class="line">            //比较月份</span><br><span class="line"></span><br><span class="line">            for (int i = beginWeek;i&lt;=endWeek;i++)&#123;</span><br><span class="line">                for (String tableName :collection)&#123;</span><br><span class="line">                    if(tableName.endsWith(beginDateYear+&quot;&quot;+i))&#123;</span><br><span class="line">                        result.add(tableName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //年份不等,遍历年份</span><br><span class="line">            for (int i = beginDateYear;i&lt;=endDateYear;i++)&#123;</span><br><span class="line">                //遍历月份</span><br><span class="line">                if(i==endDateYear)&#123;</span><br><span class="line">                    for (int j = beginWeek;j&lt;=endWeek;j++)&#123;</span><br><span class="line">                        for (String tableName :collection)&#123;</span><br><span class="line">                            if(tableName.endsWith(i+&quot;&quot;+j))&#123;</span><br><span class="line">                                result.add(tableName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    for (int j = beginWeek;j&lt;=12;j++)&#123;</span><br><span class="line">                        for (String tableName :collection)&#123;</span><br><span class="line">                            if(tableName.endsWith(i+&quot;&quot;+j))&#123;</span><br><span class="line">                                result.add(tableName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(&quot;范围查询返回的表名：&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前日期的周数</span><br><span class="line">     * @param date</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Integer getWeek(Date date)&#123;</span><br><span class="line">        Calendar instance = Calendar.getInstance();</span><br><span class="line">        instance.setFirstDayOfWeek(Calendar.MONDAY);</span><br><span class="line">        instance.setTime(date);</span><br><span class="line">        int weekNum = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        //如果为12月份</span><br><span class="line">        if((instance.get(Calendar.MONTH)+1)==12)&#123;</span><br><span class="line">            instance.add(Calendar.WEEK_OF_YEAR,-1);</span><br><span class="line">            int weekNumBefore = instance.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">            if(weekNum&lt;weekNumBefore)&#123;</span><br><span class="line">                return weekNumBefore+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return weekNum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的地方<br>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath*:application_local.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>不要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">&lt;property name=&quot;locations&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;classpath*:application_local.properties&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>不要将dataSource和shardingjdbc的规则放在一起，因为dataSource里面的${}和shardingjdbc里面的${}解析的时候用的不是一个工具。</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分表分库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于数据库水平拆分和垂直拆分</title>
      <link href="/2018/09/26/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E5%92%8C%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86/"/>
      <url>/2018/09/26/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E5%92%8C%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86/</url>
      <content type="html"><![CDATA[<p>###垂直拆分<br>垂直拆分 分为两种，一种是垂直分表，一种是垂直分库。</p><ul><li>垂直分表<br>垂直分表就是单表的列数比较多，并且有一些列存放的数据比较多，比如文章表的文章内容，或者一些列不需要经常查看的。这时可以使用垂直分表，将那些大容量的，不经常查看的列分到另一张表里面去，这样便可以增加查询的速度。</li><li>垂直分库</li></ul><p>###水平拆分</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分表分库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo集成gitalk的一些问题</title>
      <link href="/2018/09/10/hexo%E9%9B%86%E6%88%90gitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/10/hexo%E9%9B%86%E6%88%90gitalk%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h4 id="新建OAuth-APP"><a href="#新建OAuth-APP" class="headerlink" title="新建OAuth APP"></a>新建OAuth APP</h4><ul><li>在github上Settings - Developer settings右边点击新建</li><li>Application name任意填写</li><li>Homepage URL和Authorization callback URL填写博客主页</li></ul><p>新建完成后生成Client ID和Client Secret</p><h4 id="设置gitalk"><a href="#设置gitalk" class="headerlink" title="设置gitalk"></a>设置gitalk</h4><ul><li>owner 填写github用户名</li><li>repo 填写博客的github仓库名称,例如xxx.github.io</li><li>client_id 填写Client ID</li><li>client_secret 填写Client Secret</li><li>admin 填写github用户名</li></ul><p>如果评论不了,可能是github邮箱未验证,登录验证即可.</p>]]></content>
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo d 无响应 hexo deploy 提交git失败</title>
      <link href="/2018/09/07/hexo-d-%E6%97%A0%E5%93%8D%E5%BA%94-hexo-d-%E6%8F%90%E4%BA%A4git%E5%A4%B1%E8%B4%A5/"/>
      <url>/2018/09/07/hexo-d-%E6%97%A0%E5%93%8D%E5%BA%94-hexo-d-%E6%8F%90%E4%BA%A4git%E5%A4%B1%E8%B4%A5/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">develop:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:xxx/xxx.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>在type: repo: branch:的后面必须有一个空格,不然就会发生这些错误</p>]]></content>
      
      <categories>
          
          <category> Hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/07/hello-world/"/>
      <url>/2018/09/07/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
